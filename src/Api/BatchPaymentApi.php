<?php
/**
 * BatchPaymentApi
 * PHP version 8.1
 *
 * @package  SynergiTech\Iplicit
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Iplicit API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.8.0
 * @generated Generated by: https://openapi-generator.tech
 * Generator version: 7.8.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SynergiTech\Iplicit\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use SynergiTech\Iplicit\ApiException;
use SynergiTech\Iplicit\Configuration;
use SynergiTech\Iplicit\HeaderSelector;
use SynergiTech\Iplicit\ObjectSerializer;

/**
 * BatchPaymentApi Class Doc Comment
 *
 * @package  SynergiTech\Iplicit
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class BatchPaymentApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'abandonBatchPayment' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'addBatchPaymentAllocations' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'amendBatchPayment' => [
            'application/json',
        ],
        'createBatchPayment' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'deleteBatchPaymentAllocation' => [
            'application/json',
        ],
        'getBatchPayment' => [
            'application/json',
        ],
        'getBatchPayments' => [
            'application/json',
        ],
        'postBatchPayment' => [
            'application/json',
        ],
        'processBatchPayment' => [
            'application/json',
        ],
        'replaceBatchPaymentAllocations' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'submitBatchPayment' => [
            'application/json',
        ],
        'unpostBatchPayment' => [
            'application/json',
        ],
        'updateBatchPayment' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation abandonBatchPayment
     *
     * Abandon a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentAbandon|null $batchPaymentAbandon batchPaymentAbandon (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['abandonBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return string
     */
    public function abandonBatchPayment(
        string $idOrBatchNo,
        ?\SynergiTech\Iplicit\Model\BatchPaymentAbandon $batchPaymentAbandon = null,
        string $contentType = self::contentTypes['abandonBatchPayment'][0]
    ): string
    {
        list($response) = $this->abandonBatchPaymentWithHttpInfo($idOrBatchNo, $batchPaymentAbandon, $contentType);
        return $response;
    }

    /**
     * Operation abandonBatchPaymentWithHttpInfo
     *
     * Abandon a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentAbandon|null $batchPaymentAbandon (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['abandonBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function abandonBatchPaymentWithHttpInfo(
        string $idOrBatchNo,
        ?\SynergiTech\Iplicit\Model\BatchPaymentAbandon $batchPaymentAbandon = null,
        string $contentType = self::contentTypes['abandonBatchPayment'][0]
    ): array
    {
        $request = $this->abandonBatchPaymentRequest($idOrBatchNo, $batchPaymentAbandon, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('string', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation abandonBatchPaymentAsync
     *
     * Abandon a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentAbandon|null $batchPaymentAbandon (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['abandonBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function abandonBatchPaymentAsync(
        string $idOrBatchNo,
        ?\SynergiTech\Iplicit\Model\BatchPaymentAbandon $batchPaymentAbandon = null,
        string $contentType = self::contentTypes['abandonBatchPayment'][0]
    ): PromiseInterface
    {
        return $this->abandonBatchPaymentAsyncWithHttpInfo($idOrBatchNo, $batchPaymentAbandon, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation abandonBatchPaymentAsyncWithHttpInfo
     *
     * Abandon a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentAbandon|null $batchPaymentAbandon (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['abandonBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function abandonBatchPaymentAsyncWithHttpInfo(
        $idOrBatchNo,
        $batchPaymentAbandon = null,
        string $contentType = self::contentTypes['abandonBatchPayment'][0]
    ): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->abandonBatchPaymentRequest($idOrBatchNo, $batchPaymentAbandon, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'abandonBatchPayment'
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentAbandon|null $batchPaymentAbandon (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['abandonBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function abandonBatchPaymentRequest(
        $idOrBatchNo,
        $batchPaymentAbandon = null,
        string $contentType = self::contentTypes['abandonBatchPayment'][0]
    ): Request
    {

        // verify the required parameter 'idOrBatchNo' is set
        if ($idOrBatchNo === null || (is_array($idOrBatchNo) && count($idOrBatchNo) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $idOrBatchNo when calling abandonBatchPayment'
            );
        }



        $resourcePath = '/api/BatchPayment/{idOrBatchNo}/abandon';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($idOrBatchNo !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrBatchNo' . '}',
                ObjectSerializer::toPathValue($idOrBatchNo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batchPaymentAbandon)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batchPaymentAbandon));
            } else {
                $httpBody = $batchPaymentAbandon;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addBatchPaymentAllocations
     *
     * Add allocations to the batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\DocAllocationCreate[]|null $docAllocationCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addBatchPaymentAllocations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function addBatchPaymentAllocations(
        string $idOrBatchNo,
        ?array $docAllocationCreate = null,
        string $contentType = self::contentTypes['addBatchPaymentAllocations'][0]
    ): void
    {
        $this->addBatchPaymentAllocationsWithHttpInfo($idOrBatchNo, $docAllocationCreate, $contentType);
    }

    /**
     * Operation addBatchPaymentAllocationsWithHttpInfo
     *
     * Add allocations to the batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\DocAllocationCreate[]|null $docAllocationCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addBatchPaymentAllocations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addBatchPaymentAllocationsWithHttpInfo(
        string $idOrBatchNo,
        ?array $docAllocationCreate = null,
        string $contentType = self::contentTypes['addBatchPaymentAllocations'][0]
    ): array
    {
        $request = $this->addBatchPaymentAllocationsRequest($idOrBatchNo, $docAllocationCreate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation addBatchPaymentAllocationsAsync
     *
     * Add allocations to the batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\DocAllocationCreate[]|null $docAllocationCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addBatchPaymentAllocations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addBatchPaymentAllocationsAsync(
        string $idOrBatchNo,
        ?array $docAllocationCreate = null,
        string $contentType = self::contentTypes['addBatchPaymentAllocations'][0]
    ): PromiseInterface
    {
        return $this->addBatchPaymentAllocationsAsyncWithHttpInfo($idOrBatchNo, $docAllocationCreate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addBatchPaymentAllocationsAsyncWithHttpInfo
     *
     * Add allocations to the batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\DocAllocationCreate[]|null $docAllocationCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addBatchPaymentAllocations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addBatchPaymentAllocationsAsyncWithHttpInfo(
        $idOrBatchNo,
        $docAllocationCreate = null,
        string $contentType = self::contentTypes['addBatchPaymentAllocations'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->addBatchPaymentAllocationsRequest($idOrBatchNo, $docAllocationCreate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addBatchPaymentAllocations'
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\DocAllocationCreate[]|null $docAllocationCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addBatchPaymentAllocations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addBatchPaymentAllocationsRequest(
        $idOrBatchNo,
        $docAllocationCreate = null,
        string $contentType = self::contentTypes['addBatchPaymentAllocations'][0]
    ): Request
    {

        // verify the required parameter 'idOrBatchNo' is set
        if ($idOrBatchNo === null || (is_array($idOrBatchNo) && count($idOrBatchNo) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $idOrBatchNo when calling addBatchPaymentAllocations'
            );
        }



        $resourcePath = '/api/BatchPayment/{idOrBatchNo}/allocations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($idOrBatchNo !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrBatchNo' . '}',
                ObjectSerializer::toPathValue($idOrBatchNo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($docAllocationCreate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($docAllocationCreate));
            } else {
                $httpBody = $docAllocationCreate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation amendBatchPayment
     *
     * Set an approved batch payment back to draft for amending
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['amendBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return string
     */
    public function amendBatchPayment(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['amendBatchPayment'][0]
    ): string
    {
        list($response) = $this->amendBatchPaymentWithHttpInfo($idOrBatchNo, $contentType);
        return $response;
    }

    /**
     * Operation amendBatchPaymentWithHttpInfo
     *
     * Set an approved batch payment back to draft for amending
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['amendBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function amendBatchPaymentWithHttpInfo(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['amendBatchPayment'][0]
    ): array
    {
        $request = $this->amendBatchPaymentRequest($idOrBatchNo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('string', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation amendBatchPaymentAsync
     *
     * Set an approved batch payment back to draft for amending
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['amendBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function amendBatchPaymentAsync(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['amendBatchPayment'][0]
    ): PromiseInterface
    {
        return $this->amendBatchPaymentAsyncWithHttpInfo($idOrBatchNo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation amendBatchPaymentAsyncWithHttpInfo
     *
     * Set an approved batch payment back to draft for amending
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['amendBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function amendBatchPaymentAsyncWithHttpInfo(
        $idOrBatchNo,
        string $contentType = self::contentTypes['amendBatchPayment'][0]
    ): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->amendBatchPaymentRequest($idOrBatchNo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'amendBatchPayment'
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['amendBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function amendBatchPaymentRequest(
        $idOrBatchNo,
        string $contentType = self::contentTypes['amendBatchPayment'][0]
    ): Request
    {

        // verify the required parameter 'idOrBatchNo' is set
        if ($idOrBatchNo === null || (is_array($idOrBatchNo) && count($idOrBatchNo) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $idOrBatchNo when calling amendBatchPayment'
            );
        }


        $resourcePath = '/api/BatchPayment/{idOrBatchNo}/amend';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($idOrBatchNo !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrBatchNo' . '}',
                ObjectSerializer::toPathValue($idOrBatchNo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createBatchPayment
     *
     * Create a batch payment
     *
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentCreate|null $batchPaymentCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return string
     */
    public function createBatchPayment(
        ?\SynergiTech\Iplicit\Model\BatchPaymentCreate $batchPaymentCreate = null,
        string $contentType = self::contentTypes['createBatchPayment'][0]
    ): string
    {
        list($response) = $this->createBatchPaymentWithHttpInfo($batchPaymentCreate, $contentType);
        return $response;
    }

    /**
     * Operation createBatchPaymentWithHttpInfo
     *
     * Create a batch payment
     *
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentCreate|null $batchPaymentCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBatchPaymentWithHttpInfo(
        ?\SynergiTech\Iplicit\Model\BatchPaymentCreate $batchPaymentCreate = null,
        string $contentType = self::contentTypes['createBatchPayment'][0]
    ): array
    {
        $request = $this->createBatchPaymentRequest($batchPaymentCreate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('string', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBatchPaymentAsync
     *
     * Create a batch payment
     *
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentCreate|null $batchPaymentCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createBatchPaymentAsync(
        ?\SynergiTech\Iplicit\Model\BatchPaymentCreate $batchPaymentCreate = null,
        string $contentType = self::contentTypes['createBatchPayment'][0]
    ): PromiseInterface
    {
        return $this->createBatchPaymentAsyncWithHttpInfo($batchPaymentCreate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBatchPaymentAsyncWithHttpInfo
     *
     * Create a batch payment
     *
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentCreate|null $batchPaymentCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createBatchPaymentAsyncWithHttpInfo(
        $batchPaymentCreate = null,
        string $contentType = self::contentTypes['createBatchPayment'][0]
    ): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->createBatchPaymentRequest($batchPaymentCreate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBatchPayment'
     *
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentCreate|null $batchPaymentCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createBatchPaymentRequest(
        $batchPaymentCreate = null,
        string $contentType = self::contentTypes['createBatchPayment'][0]
    ): Request
    {



        $resourcePath = '/api/BatchPayment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batchPaymentCreate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batchPaymentCreate));
            } else {
                $httpBody = $batchPaymentCreate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBatchPaymentAllocation
     *
     * Delete an allocation in the batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $allocationId Batch payment allocation id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBatchPaymentAllocation'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteBatchPaymentAllocation(
        string $idOrBatchNo,
        string $allocationId,
        string $contentType = self::contentTypes['deleteBatchPaymentAllocation'][0]
    ): void
    {
        $this->deleteBatchPaymentAllocationWithHttpInfo($idOrBatchNo, $allocationId, $contentType);
    }

    /**
     * Operation deleteBatchPaymentAllocationWithHttpInfo
     *
     * Delete an allocation in the batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $allocationId Batch payment allocation id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBatchPaymentAllocation'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBatchPaymentAllocationWithHttpInfo(
        string $idOrBatchNo,
        string $allocationId,
        string $contentType = self::contentTypes['deleteBatchPaymentAllocation'][0]
    ): array
    {
        $request = $this->deleteBatchPaymentAllocationRequest($idOrBatchNo, $allocationId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBatchPaymentAllocationAsync
     *
     * Delete an allocation in the batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $allocationId Batch payment allocation id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBatchPaymentAllocation'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteBatchPaymentAllocationAsync(
        string $idOrBatchNo,
        string $allocationId,
        string $contentType = self::contentTypes['deleteBatchPaymentAllocation'][0]
    ): PromiseInterface
    {
        return $this->deleteBatchPaymentAllocationAsyncWithHttpInfo($idOrBatchNo, $allocationId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBatchPaymentAllocationAsyncWithHttpInfo
     *
     * Delete an allocation in the batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $allocationId Batch payment allocation id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBatchPaymentAllocation'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteBatchPaymentAllocationAsyncWithHttpInfo(
        $idOrBatchNo,
        $allocationId,
        string $contentType = self::contentTypes['deleteBatchPaymentAllocation'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteBatchPaymentAllocationRequest($idOrBatchNo, $allocationId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBatchPaymentAllocation'
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $allocationId Batch payment allocation id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBatchPaymentAllocation'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteBatchPaymentAllocationRequest(
        $idOrBatchNo,
        $allocationId,
        string $contentType = self::contentTypes['deleteBatchPaymentAllocation'][0]
    ): Request
    {

        // verify the required parameter 'idOrBatchNo' is set
        if ($idOrBatchNo === null || (is_array($idOrBatchNo) && count($idOrBatchNo) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $idOrBatchNo when calling deleteBatchPaymentAllocation'
            );
        }

        // verify the required parameter 'allocationId' is set
        if ($allocationId === null || (is_array($allocationId) && count($allocationId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $allocationId when calling deleteBatchPaymentAllocation'
            );
        }


        $resourcePath = '/api/BatchPayment/{idOrBatchNo}/allocations/{allocationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($idOrBatchNo !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrBatchNo' . '}',
                ObjectSerializer::toPathValue($idOrBatchNo),
                $resourcePath
            );
        }
        // path params
        if ($allocationId !== null) {
            $resourcePath = str_replace(
                '{' . 'allocationId' . '}',
                ObjectSerializer::toPathValue($allocationId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBatchPayment
     *
     * Get a batch payment by id or by batch number.
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Iplicit\Model\BatchPaymentDetail
     */
    public function getBatchPayment(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['getBatchPayment'][0]
    ): \SynergiTech\Iplicit\Model\BatchPaymentDetail
    {
        list($response) = $this->getBatchPaymentWithHttpInfo($idOrBatchNo, $contentType);
        return $response;
    }

    /**
     * Operation getBatchPaymentWithHttpInfo
     *
     * Get a batch payment by id or by batch number.
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Iplicit\Model\BatchPaymentDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBatchPaymentWithHttpInfo(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['getBatchPayment'][0]
    ): array
    {
        $request = $this->getBatchPaymentRequest($idOrBatchNo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Iplicit\Model\BatchPaymentDetail', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Iplicit\Model\BatchPaymentDetail' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Iplicit\Model\BatchPaymentDetail', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SynergiTech\Iplicit\Model\BatchPaymentDetail';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Iplicit\Model\BatchPaymentDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBatchPaymentAsync
     *
     * Get a batch payment by id or by batch number.
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getBatchPaymentAsync(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['getBatchPayment'][0]
    ): PromiseInterface
    {
        return $this->getBatchPaymentAsyncWithHttpInfo($idOrBatchNo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBatchPaymentAsyncWithHttpInfo
     *
     * Get a batch payment by id or by batch number.
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getBatchPaymentAsyncWithHttpInfo(
        $idOrBatchNo,
        string $contentType = self::contentTypes['getBatchPayment'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Iplicit\Model\BatchPaymentDetail';
        $request = $this->getBatchPaymentRequest($idOrBatchNo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBatchPayment'
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBatchPaymentRequest(
        $idOrBatchNo,
        string $contentType = self::contentTypes['getBatchPayment'][0]
    ): Request
    {

        // verify the required parameter 'idOrBatchNo' is set
        if ($idOrBatchNo === null || (is_array($idOrBatchNo) && count($idOrBatchNo) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $idOrBatchNo when calling getBatchPayment'
            );
        }


        $resourcePath = '/api/BatchPayment/{idOrBatchNo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($idOrBatchNo !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrBatchNo' . '}',
                ObjectSerializer::toPathValue($idOrBatchNo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBatchPayments
     *
     * Get batch payments with a search filter
     *
     * @param  string|null $batchNo Filter on the batch payment number (optional)
     * @param  string|null $batchPaymentType Filter on the batch payment type (optional)
     * @param  string|null $legalEntity Filter on the legal entity (optional)
     * @param  string|null $bankAccountId Filter on the bank account id (optional)
     * @param  string|null $description Filter on the description (optional)
     * @param  string|null $descriptionContains Filter on the description that contains (optional)
     * @param  \DateTime|null $paymentDateFrom The batch payment date from (optional)
     * @param  \DateTime|null $paymentDateTo Filter on the batch payment date to (optional)
     * @param  \DateTime|null $lastModifiedFrom Filter on the batch payment last modified from date (optional)
     * @param  \DateTime|null $lastModifiedTo Filter on the batch payment last modified to date (optional)
     * @param  string|null $lastModifiedBy The user that last modified this item. See &#x60;UserAccount&#x60; catalog. (optional)
     * @param  bool|null $isDraft Filter on a flag indicating whether the batch is in draft (optional)
     * @param  bool|null $isPosted Filter on a flag indicating whether the batch is posted (optional)
     * @param  bool|null $isApproved Filter on a flag indicating whether the batch is approved (optional)
     * @param  bool|null $isProcessed Filter on a flag indicating whether the batch is processed (optional)
     * @param  int|null $take The number of records to return (optional, default to 100)
     * @param  int|null $skip The number of records to skip (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatchPayments'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Iplicit\Model\BatchPaymentSummary[]
     */
    public function getBatchPayments(
        ?string $batchNo = null,
        ?string $batchPaymentType = null,
        ?string $legalEntity = null,
        ?string $bankAccountId = null,
        ?string $description = null,
        ?string $descriptionContains = null,
        ?\DateTime $paymentDateFrom = null,
        ?\DateTime $paymentDateTo = null,
        ?\DateTime $lastModifiedFrom = null,
        ?\DateTime $lastModifiedTo = null,
        ?string $lastModifiedBy = null,
        ?bool $isDraft = null,
        ?bool $isPosted = null,
        ?bool $isApproved = null,
        ?bool $isProcessed = null,
        ?int $take = 100,
        ?int $skip = 0,
        string $contentType = self::contentTypes['getBatchPayments'][0]
    ): array
    {
        list($response) = $this->getBatchPaymentsWithHttpInfo($batchNo, $batchPaymentType, $legalEntity, $bankAccountId, $description, $descriptionContains, $paymentDateFrom, $paymentDateTo, $lastModifiedFrom, $lastModifiedTo, $lastModifiedBy, $isDraft, $isPosted, $isApproved, $isProcessed, $take, $skip, $contentType);
        return $response;
    }

    /**
     * Operation getBatchPaymentsWithHttpInfo
     *
     * Get batch payments with a search filter
     *
     * @param  string|null $batchNo Filter on the batch payment number (optional)
     * @param  string|null $batchPaymentType Filter on the batch payment type (optional)
     * @param  string|null $legalEntity Filter on the legal entity (optional)
     * @param  string|null $bankAccountId Filter on the bank account id (optional)
     * @param  string|null $description Filter on the description (optional)
     * @param  string|null $descriptionContains Filter on the description that contains (optional)
     * @param  \DateTime|null $paymentDateFrom The batch payment date from (optional)
     * @param  \DateTime|null $paymentDateTo Filter on the batch payment date to (optional)
     * @param  \DateTime|null $lastModifiedFrom Filter on the batch payment last modified from date (optional)
     * @param  \DateTime|null $lastModifiedTo Filter on the batch payment last modified to date (optional)
     * @param  string|null $lastModifiedBy The user that last modified this item. See &#x60;UserAccount&#x60; catalog. (optional)
     * @param  bool|null $isDraft Filter on a flag indicating whether the batch is in draft (optional)
     * @param  bool|null $isPosted Filter on a flag indicating whether the batch is posted (optional)
     * @param  bool|null $isApproved Filter on a flag indicating whether the batch is approved (optional)
     * @param  bool|null $isProcessed Filter on a flag indicating whether the batch is processed (optional)
     * @param  int|null $take The number of records to return (optional, default to 100)
     * @param  int|null $skip The number of records to skip (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatchPayments'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Iplicit\Model\BatchPaymentSummary[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getBatchPaymentsWithHttpInfo(
        ?string $batchNo = null,
        ?string $batchPaymentType = null,
        ?string $legalEntity = null,
        ?string $bankAccountId = null,
        ?string $description = null,
        ?string $descriptionContains = null,
        ?\DateTime $paymentDateFrom = null,
        ?\DateTime $paymentDateTo = null,
        ?\DateTime $lastModifiedFrom = null,
        ?\DateTime $lastModifiedTo = null,
        ?string $lastModifiedBy = null,
        ?bool $isDraft = null,
        ?bool $isPosted = null,
        ?bool $isApproved = null,
        ?bool $isProcessed = null,
        ?int $take = 100,
        ?int $skip = 0,
        string $contentType = self::contentTypes['getBatchPayments'][0]
    ): array
    {
        $request = $this->getBatchPaymentsRequest($batchNo, $batchPaymentType, $legalEntity, $bankAccountId, $description, $descriptionContains, $paymentDateFrom, $paymentDateTo, $lastModifiedFrom, $lastModifiedTo, $lastModifiedBy, $isDraft, $isPosted, $isApproved, $isProcessed, $take, $skip, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Iplicit\Model\BatchPaymentSummary[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Iplicit\Model\BatchPaymentSummary[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Iplicit\Model\BatchPaymentSummary[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SynergiTech\Iplicit\Model\BatchPaymentSummary[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Iplicit\Model\BatchPaymentSummary[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBatchPaymentsAsync
     *
     * Get batch payments with a search filter
     *
     * @param  string|null $batchNo Filter on the batch payment number (optional)
     * @param  string|null $batchPaymentType Filter on the batch payment type (optional)
     * @param  string|null $legalEntity Filter on the legal entity (optional)
     * @param  string|null $bankAccountId Filter on the bank account id (optional)
     * @param  string|null $description Filter on the description (optional)
     * @param  string|null $descriptionContains Filter on the description that contains (optional)
     * @param  \DateTime|null $paymentDateFrom The batch payment date from (optional)
     * @param  \DateTime|null $paymentDateTo Filter on the batch payment date to (optional)
     * @param  \DateTime|null $lastModifiedFrom Filter on the batch payment last modified from date (optional)
     * @param  \DateTime|null $lastModifiedTo Filter on the batch payment last modified to date (optional)
     * @param  string|null $lastModifiedBy The user that last modified this item. See &#x60;UserAccount&#x60; catalog. (optional)
     * @param  bool|null $isDraft Filter on a flag indicating whether the batch is in draft (optional)
     * @param  bool|null $isPosted Filter on a flag indicating whether the batch is posted (optional)
     * @param  bool|null $isApproved Filter on a flag indicating whether the batch is approved (optional)
     * @param  bool|null $isProcessed Filter on a flag indicating whether the batch is processed (optional)
     * @param  int|null $take The number of records to return (optional, default to 100)
     * @param  int|null $skip The number of records to skip (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatchPayments'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getBatchPaymentsAsync(
        ?string $batchNo = null,
        ?string $batchPaymentType = null,
        ?string $legalEntity = null,
        ?string $bankAccountId = null,
        ?string $description = null,
        ?string $descriptionContains = null,
        ?\DateTime $paymentDateFrom = null,
        ?\DateTime $paymentDateTo = null,
        ?\DateTime $lastModifiedFrom = null,
        ?\DateTime $lastModifiedTo = null,
        ?string $lastModifiedBy = null,
        ?bool $isDraft = null,
        ?bool $isPosted = null,
        ?bool $isApproved = null,
        ?bool $isProcessed = null,
        ?int $take = 100,
        ?int $skip = 0,
        string $contentType = self::contentTypes['getBatchPayments'][0]
    ): PromiseInterface
    {
        return $this->getBatchPaymentsAsyncWithHttpInfo($batchNo, $batchPaymentType, $legalEntity, $bankAccountId, $description, $descriptionContains, $paymentDateFrom, $paymentDateTo, $lastModifiedFrom, $lastModifiedTo, $lastModifiedBy, $isDraft, $isPosted, $isApproved, $isProcessed, $take, $skip, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBatchPaymentsAsyncWithHttpInfo
     *
     * Get batch payments with a search filter
     *
     * @param  string|null $batchNo Filter on the batch payment number (optional)
     * @param  string|null $batchPaymentType Filter on the batch payment type (optional)
     * @param  string|null $legalEntity Filter on the legal entity (optional)
     * @param  string|null $bankAccountId Filter on the bank account id (optional)
     * @param  string|null $description Filter on the description (optional)
     * @param  string|null $descriptionContains Filter on the description that contains (optional)
     * @param  \DateTime|null $paymentDateFrom The batch payment date from (optional)
     * @param  \DateTime|null $paymentDateTo Filter on the batch payment date to (optional)
     * @param  \DateTime|null $lastModifiedFrom Filter on the batch payment last modified from date (optional)
     * @param  \DateTime|null $lastModifiedTo Filter on the batch payment last modified to date (optional)
     * @param  string|null $lastModifiedBy The user that last modified this item. See &#x60;UserAccount&#x60; catalog. (optional)
     * @param  bool|null $isDraft Filter on a flag indicating whether the batch is in draft (optional)
     * @param  bool|null $isPosted Filter on a flag indicating whether the batch is posted (optional)
     * @param  bool|null $isApproved Filter on a flag indicating whether the batch is approved (optional)
     * @param  bool|null $isProcessed Filter on a flag indicating whether the batch is processed (optional)
     * @param  int|null $take The number of records to return (optional, default to 100)
     * @param  int|null $skip The number of records to skip (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatchPayments'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getBatchPaymentsAsyncWithHttpInfo(
        $batchNo = null,
        $batchPaymentType = null,
        $legalEntity = null,
        $bankAccountId = null,
        $description = null,
        $descriptionContains = null,
        $paymentDateFrom = null,
        $paymentDateTo = null,
        $lastModifiedFrom = null,
        $lastModifiedTo = null,
        $lastModifiedBy = null,
        $isDraft = null,
        $isPosted = null,
        $isApproved = null,
        $isProcessed = null,
        $take = 100,
        $skip = 0,
        string $contentType = self::contentTypes['getBatchPayments'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Iplicit\Model\BatchPaymentSummary[]';
        $request = $this->getBatchPaymentsRequest($batchNo, $batchPaymentType, $legalEntity, $bankAccountId, $description, $descriptionContains, $paymentDateFrom, $paymentDateTo, $lastModifiedFrom, $lastModifiedTo, $lastModifiedBy, $isDraft, $isPosted, $isApproved, $isProcessed, $take, $skip, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBatchPayments'
     *
     * @param  string|null $batchNo Filter on the batch payment number (optional)
     * @param  string|null $batchPaymentType Filter on the batch payment type (optional)
     * @param  string|null $legalEntity Filter on the legal entity (optional)
     * @param  string|null $bankAccountId Filter on the bank account id (optional)
     * @param  string|null $description Filter on the description (optional)
     * @param  string|null $descriptionContains Filter on the description that contains (optional)
     * @param  \DateTime|null $paymentDateFrom The batch payment date from (optional)
     * @param  \DateTime|null $paymentDateTo Filter on the batch payment date to (optional)
     * @param  \DateTime|null $lastModifiedFrom Filter on the batch payment last modified from date (optional)
     * @param  \DateTime|null $lastModifiedTo Filter on the batch payment last modified to date (optional)
     * @param  string|null $lastModifiedBy The user that last modified this item. See &#x60;UserAccount&#x60; catalog. (optional)
     * @param  bool|null $isDraft Filter on a flag indicating whether the batch is in draft (optional)
     * @param  bool|null $isPosted Filter on a flag indicating whether the batch is posted (optional)
     * @param  bool|null $isApproved Filter on a flag indicating whether the batch is approved (optional)
     * @param  bool|null $isProcessed Filter on a flag indicating whether the batch is processed (optional)
     * @param  int|null $take The number of records to return (optional, default to 100)
     * @param  int|null $skip The number of records to skip (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBatchPayments'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBatchPaymentsRequest(
        $batchNo = null,
        $batchPaymentType = null,
        $legalEntity = null,
        $bankAccountId = null,
        $description = null,
        $descriptionContains = null,
        $paymentDateFrom = null,
        $paymentDateTo = null,
        $lastModifiedFrom = null,
        $lastModifiedTo = null,
        $lastModifiedBy = null,
        $isDraft = null,
        $isPosted = null,
        $isApproved = null,
        $isProcessed = null,
        $take = 100,
        $skip = 0,
        string $contentType = self::contentTypes['getBatchPayments'][0]
    ): Request
    {

        if ($batchNo !== null && strlen($batchNo) > 50) {
            throw new InvalidArgumentException('invalid length for "$batchNo" when calling BatchPaymentApi.getBatchPayments, must be smaller than or equal to 50.');
        }
        
        if ($batchPaymentType !== null && strlen($batchPaymentType) > 50) {
            throw new InvalidArgumentException('invalid length for "$batchPaymentType" when calling BatchPaymentApi.getBatchPayments, must be smaller than or equal to 50.');
        }
        
        if ($legalEntity !== null && strlen($legalEntity) > 50) {
            throw new InvalidArgumentException('invalid length for "$legalEntity" when calling BatchPaymentApi.getBatchPayments, must be smaller than or equal to 50.');
        }
        
        if ($bankAccountId !== null && strlen($bankAccountId) > 50) {
            throw new InvalidArgumentException('invalid length for "$bankAccountId" when calling BatchPaymentApi.getBatchPayments, must be smaller than or equal to 50.');
        }
        
        if ($description !== null && strlen($description) > 250) {
            throw new InvalidArgumentException('invalid length for "$description" when calling BatchPaymentApi.getBatchPayments, must be smaller than or equal to 250.');
        }
        
        if ($descriptionContains !== null && strlen($descriptionContains) > 250) {
            throw new InvalidArgumentException('invalid length for "$descriptionContains" when calling BatchPaymentApi.getBatchPayments, must be smaller than or equal to 250.');
        }
        




        if ($lastModifiedBy !== null && strlen($lastModifiedBy) > 64) {
            throw new InvalidArgumentException('invalid length for "$lastModifiedBy" when calling BatchPaymentApi.getBatchPayments, must be smaller than or equal to 64.');
        }
        







        $resourcePath = '/api/BatchPayment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $batchNo,
            'BatchNo', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $batchPaymentType,
            'BatchPaymentType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $legalEntity,
            'LegalEntity', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $bankAccountId,
            'BankAccountId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'Description', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descriptionContains,
            'DescriptionContains', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $paymentDateFrom,
            'PaymentDateFrom', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $paymentDateTo,
            'PaymentDateTo', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lastModifiedFrom,
            'LastModifiedFrom', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lastModifiedTo,
            'LastModifiedTo', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lastModifiedBy,
            'LastModifiedBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isDraft,
            'IsDraft', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isPosted,
            'IsPosted', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isApproved,
            'IsApproved', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isProcessed,
            'IsProcessed', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take,
            'take', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postBatchPayment
     *
     * Post a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return string
     */
    public function postBatchPayment(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['postBatchPayment'][0]
    ): string
    {
        list($response) = $this->postBatchPaymentWithHttpInfo($idOrBatchNo, $contentType);
        return $response;
    }

    /**
     * Operation postBatchPaymentWithHttpInfo
     *
     * Post a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function postBatchPaymentWithHttpInfo(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['postBatchPayment'][0]
    ): array
    {
        $request = $this->postBatchPaymentRequest($idOrBatchNo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('string', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postBatchPaymentAsync
     *
     * Post a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function postBatchPaymentAsync(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['postBatchPayment'][0]
    ): PromiseInterface
    {
        return $this->postBatchPaymentAsyncWithHttpInfo($idOrBatchNo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postBatchPaymentAsyncWithHttpInfo
     *
     * Post a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function postBatchPaymentAsyncWithHttpInfo(
        $idOrBatchNo,
        string $contentType = self::contentTypes['postBatchPayment'][0]
    ): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->postBatchPaymentRequest($idOrBatchNo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postBatchPayment'
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postBatchPaymentRequest(
        $idOrBatchNo,
        string $contentType = self::contentTypes['postBatchPayment'][0]
    ): Request
    {

        // verify the required parameter 'idOrBatchNo' is set
        if ($idOrBatchNo === null || (is_array($idOrBatchNo) && count($idOrBatchNo) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $idOrBatchNo when calling postBatchPayment'
            );
        }


        $resourcePath = '/api/BatchPayment/{idOrBatchNo}/post';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($idOrBatchNo !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrBatchNo' . '}',
                ObjectSerializer::toPathValue($idOrBatchNo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation processBatchPayment
     *
     * Process a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return string
     */
    public function processBatchPayment(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['processBatchPayment'][0]
    ): string
    {
        list($response) = $this->processBatchPaymentWithHttpInfo($idOrBatchNo, $contentType);
        return $response;
    }

    /**
     * Operation processBatchPaymentWithHttpInfo
     *
     * Process a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function processBatchPaymentWithHttpInfo(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['processBatchPayment'][0]
    ): array
    {
        $request = $this->processBatchPaymentRequest($idOrBatchNo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('string', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation processBatchPaymentAsync
     *
     * Process a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function processBatchPaymentAsync(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['processBatchPayment'][0]
    ): PromiseInterface
    {
        return $this->processBatchPaymentAsyncWithHttpInfo($idOrBatchNo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation processBatchPaymentAsyncWithHttpInfo
     *
     * Process a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function processBatchPaymentAsyncWithHttpInfo(
        $idOrBatchNo,
        string $contentType = self::contentTypes['processBatchPayment'][0]
    ): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->processBatchPaymentRequest($idOrBatchNo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'processBatchPayment'
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['processBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function processBatchPaymentRequest(
        $idOrBatchNo,
        string $contentType = self::contentTypes['processBatchPayment'][0]
    ): Request
    {

        // verify the required parameter 'idOrBatchNo' is set
        if ($idOrBatchNo === null || (is_array($idOrBatchNo) && count($idOrBatchNo) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $idOrBatchNo when calling processBatchPayment'
            );
        }


        $resourcePath = '/api/BatchPayment/{idOrBatchNo}/process';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($idOrBatchNo !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrBatchNo' . '}',
                ObjectSerializer::toPathValue($idOrBatchNo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceBatchPaymentAllocations
     *
     * Replaces all allocations in the batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\DocAllocationCreate[]|null $docAllocationCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceBatchPaymentAllocations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function replaceBatchPaymentAllocations(
        string $idOrBatchNo,
        ?array $docAllocationCreate = null,
        string $contentType = self::contentTypes['replaceBatchPaymentAllocations'][0]
    ): void
    {
        $this->replaceBatchPaymentAllocationsWithHttpInfo($idOrBatchNo, $docAllocationCreate, $contentType);
    }

    /**
     * Operation replaceBatchPaymentAllocationsWithHttpInfo
     *
     * Replaces all allocations in the batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\DocAllocationCreate[]|null $docAllocationCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceBatchPaymentAllocations'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceBatchPaymentAllocationsWithHttpInfo(
        string $idOrBatchNo,
        ?array $docAllocationCreate = null,
        string $contentType = self::contentTypes['replaceBatchPaymentAllocations'][0]
    ): array
    {
        $request = $this->replaceBatchPaymentAllocationsRequest($idOrBatchNo, $docAllocationCreate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation replaceBatchPaymentAllocationsAsync
     *
     * Replaces all allocations in the batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\DocAllocationCreate[]|null $docAllocationCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceBatchPaymentAllocations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function replaceBatchPaymentAllocationsAsync(
        string $idOrBatchNo,
        ?array $docAllocationCreate = null,
        string $contentType = self::contentTypes['replaceBatchPaymentAllocations'][0]
    ): PromiseInterface
    {
        return $this->replaceBatchPaymentAllocationsAsyncWithHttpInfo($idOrBatchNo, $docAllocationCreate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceBatchPaymentAllocationsAsyncWithHttpInfo
     *
     * Replaces all allocations in the batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\DocAllocationCreate[]|null $docAllocationCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceBatchPaymentAllocations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function replaceBatchPaymentAllocationsAsyncWithHttpInfo(
        $idOrBatchNo,
        $docAllocationCreate = null,
        string $contentType = self::contentTypes['replaceBatchPaymentAllocations'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->replaceBatchPaymentAllocationsRequest($idOrBatchNo, $docAllocationCreate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceBatchPaymentAllocations'
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  \SynergiTech\Iplicit\Model\DocAllocationCreate[]|null $docAllocationCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceBatchPaymentAllocations'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function replaceBatchPaymentAllocationsRequest(
        $idOrBatchNo,
        $docAllocationCreate = null,
        string $contentType = self::contentTypes['replaceBatchPaymentAllocations'][0]
    ): Request
    {

        // verify the required parameter 'idOrBatchNo' is set
        if ($idOrBatchNo === null || (is_array($idOrBatchNo) && count($idOrBatchNo) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $idOrBatchNo when calling replaceBatchPaymentAllocations'
            );
        }



        $resourcePath = '/api/BatchPayment/{idOrBatchNo}/allocations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($idOrBatchNo !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrBatchNo' . '}',
                ObjectSerializer::toPathValue($idOrBatchNo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($docAllocationCreate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($docAllocationCreate));
            } else {
                $httpBody = $docAllocationCreate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation submitBatchPayment
     *
     * Submit a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return string
     */
    public function submitBatchPayment(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['submitBatchPayment'][0]
    ): string
    {
        list($response) = $this->submitBatchPaymentWithHttpInfo($idOrBatchNo, $contentType);
        return $response;
    }

    /**
     * Operation submitBatchPaymentWithHttpInfo
     *
     * Submit a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function submitBatchPaymentWithHttpInfo(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['submitBatchPayment'][0]
    ): array
    {
        $request = $this->submitBatchPaymentRequest($idOrBatchNo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('string', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation submitBatchPaymentAsync
     *
     * Submit a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function submitBatchPaymentAsync(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['submitBatchPayment'][0]
    ): PromiseInterface
    {
        return $this->submitBatchPaymentAsyncWithHttpInfo($idOrBatchNo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation submitBatchPaymentAsyncWithHttpInfo
     *
     * Submit a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function submitBatchPaymentAsyncWithHttpInfo(
        $idOrBatchNo,
        string $contentType = self::contentTypes['submitBatchPayment'][0]
    ): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->submitBatchPaymentRequest($idOrBatchNo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'submitBatchPayment'
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['submitBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function submitBatchPaymentRequest(
        $idOrBatchNo,
        string $contentType = self::contentTypes['submitBatchPayment'][0]
    ): Request
    {

        // verify the required parameter 'idOrBatchNo' is set
        if ($idOrBatchNo === null || (is_array($idOrBatchNo) && count($idOrBatchNo) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $idOrBatchNo when calling submitBatchPayment'
            );
        }


        $resourcePath = '/api/BatchPayment/{idOrBatchNo}/submit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($idOrBatchNo !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrBatchNo' . '}',
                ObjectSerializer::toPathValue($idOrBatchNo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unpostBatchPayment
     *
     * Unpost a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpostBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return string
     */
    public function unpostBatchPayment(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['unpostBatchPayment'][0]
    ): string
    {
        list($response) = $this->unpostBatchPaymentWithHttpInfo($idOrBatchNo, $contentType);
        return $response;
    }

    /**
     * Operation unpostBatchPaymentWithHttpInfo
     *
     * Unpost a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpostBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function unpostBatchPaymentWithHttpInfo(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['unpostBatchPayment'][0]
    ): array
    {
        $request = $this->unpostBatchPaymentRequest($idOrBatchNo, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('string', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unpostBatchPaymentAsync
     *
     * Unpost a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpostBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unpostBatchPaymentAsync(
        string $idOrBatchNo,
        string $contentType = self::contentTypes['unpostBatchPayment'][0]
    ): PromiseInterface
    {
        return $this->unpostBatchPaymentAsyncWithHttpInfo($idOrBatchNo, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unpostBatchPaymentAsyncWithHttpInfo
     *
     * Unpost a batch payment
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpostBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unpostBatchPaymentAsyncWithHttpInfo(
        $idOrBatchNo,
        string $contentType = self::contentTypes['unpostBatchPayment'][0]
    ): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->unpostBatchPaymentRequest($idOrBatchNo, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unpostBatchPayment'
     *
     * @param  string $idOrBatchNo Batch payment id or batch number (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpostBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unpostBatchPaymentRequest(
        $idOrBatchNo,
        string $contentType = self::contentTypes['unpostBatchPayment'][0]
    ): Request
    {

        // verify the required parameter 'idOrBatchNo' is set
        if ($idOrBatchNo === null || (is_array($idOrBatchNo) && count($idOrBatchNo) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $idOrBatchNo when calling unpostBatchPayment'
            );
        }


        $resourcePath = '/api/BatchPayment/{idOrBatchNo}/unpost';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($idOrBatchNo !== null) {
            $resourcePath = str_replace(
                '{' . 'idOrBatchNo' . '}',
                ObjectSerializer::toPathValue($idOrBatchNo),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBatchPayment
     *
     * Update a batch payment
     *
     * @param  string $batchPaymentId Batch payment id (required)
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentUpdate|null $batchPaymentUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function updateBatchPayment(
        string $batchPaymentId,
        ?\SynergiTech\Iplicit\Model\BatchPaymentUpdate $batchPaymentUpdate = null,
        string $contentType = self::contentTypes['updateBatchPayment'][0]
    ): void
    {
        $this->updateBatchPaymentWithHttpInfo($batchPaymentId, $batchPaymentUpdate, $contentType);
    }

    /**
     * Operation updateBatchPaymentWithHttpInfo
     *
     * Update a batch payment
     *
     * @param  string $batchPaymentId Batch payment id (required)
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentUpdate|null $batchPaymentUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBatchPayment'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBatchPaymentWithHttpInfo(
        string $batchPaymentId,
        ?\SynergiTech\Iplicit\Model\BatchPaymentUpdate $batchPaymentUpdate = null,
        string $contentType = self::contentTypes['updateBatchPayment'][0]
    ): array
    {
        $request = $this->updateBatchPaymentRequest($batchPaymentId, $batchPaymentUpdate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateBatchPaymentAsync
     *
     * Update a batch payment
     *
     * @param  string $batchPaymentId Batch payment id (required)
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentUpdate|null $batchPaymentUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateBatchPaymentAsync(
        string $batchPaymentId,
        ?\SynergiTech\Iplicit\Model\BatchPaymentUpdate $batchPaymentUpdate = null,
        string $contentType = self::contentTypes['updateBatchPayment'][0]
    ): PromiseInterface
    {
        return $this->updateBatchPaymentAsyncWithHttpInfo($batchPaymentId, $batchPaymentUpdate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBatchPaymentAsyncWithHttpInfo
     *
     * Update a batch payment
     *
     * @param  string $batchPaymentId Batch payment id (required)
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentUpdate|null $batchPaymentUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateBatchPaymentAsyncWithHttpInfo(
        $batchPaymentId,
        $batchPaymentUpdate = null,
        string $contentType = self::contentTypes['updateBatchPayment'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->updateBatchPaymentRequest($batchPaymentId, $batchPaymentUpdate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBatchPayment'
     *
     * @param  string $batchPaymentId Batch payment id (required)
     * @param  \SynergiTech\Iplicit\Model\BatchPaymentUpdate|null $batchPaymentUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateBatchPayment'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateBatchPaymentRequest(
        $batchPaymentId,
        $batchPaymentUpdate = null,
        string $contentType = self::contentTypes['updateBatchPayment'][0]
    ): Request
    {

        // verify the required parameter 'batchPaymentId' is set
        if ($batchPaymentId === null || (is_array($batchPaymentId) && count($batchPaymentId) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $batchPaymentId when calling updateBatchPayment'
            );
        }



        $resourcePath = '/api/BatchPayment/{batchPaymentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($batchPaymentId !== null) {
            $resourcePath = str_replace(
                '{' . 'batchPaymentId' . '}',
                ObjectSerializer::toPathValue($batchPaymentId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batchPaymentUpdate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batchPaymentUpdate));
            } else {
                $httpBody = $batchPaymentUpdate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
