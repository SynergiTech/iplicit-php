<?php
/**
 * ContactAccountApi
 * PHP version 8.1
 *
 * @package  SynergiTech\Iplicit
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Iplicit API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.8.0
 * @generated Generated by: https://openapi-generator.tech
 * Generator version: 7.8.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace SynergiTech\Iplicit\Api;

use InvalidArgumentException;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use GuzzleHttp\Promise\PromiseInterface;
use SynergiTech\Iplicit\ApiException;
use SynergiTech\Iplicit\Configuration;
use SynergiTech\Iplicit\HeaderSelector;
use SynergiTech\Iplicit\ObjectSerializer;

/**
 * ContactAccountApi Class Doc Comment
 *
 * @package  SynergiTech\Iplicit
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ContactAccountApi
{
    /**
     * @var ClientInterface
     */
    protected ClientInterface $client;

    /**
     * @var Configuration
     */
    protected Configuration $config;

    /**
     * @var HeaderSelector
     */
    protected HeaderSelector $headerSelector;

    /**
     * @var int Host index
     */
    protected int $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addContactAccountContact' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'addContactToContactAccount' => [
            'application/json',
        ],
        'createContactAccount' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'deleteContactAccount' => [
            'application/json',
        ],
        'deleteContactFromContactAccount' => [
            'application/json',
        ],
        'getContactAccount' => [
            'application/json',
        ],
        'getContactAccountBankAccounts' => [
            'application/json',
        ],
        'getContactAccountCustomerDetails' => [
            'application/json',
        ],
        'getContactAccountDefaultBankAccount' => [
            'application/json',
        ],
        'getContactAccountMainContact' => [
            'application/json',
        ],
        'getContactAccountRelatedContact' => [
            'application/json',
        ],
        'getContactAccountRelatedContacts' => [
            'application/json',
        ],
        'getContactAccountResource' => [
            'application/json',
        ],
        'getContactAccountSupplierDefaults' => [
            'application/json',
        ],
        'getContactAccounts' => [
            'application/json',
        ],
        'lockContactAccount' => [
            'application/json',
        ],
        'lockContactAccountResource' => [
            'application/json',
        ],
        'lockCustomer' => [
            'application/json',
        ],
        'lockSupplier' => [
            'application/json',
        ],
        'unlockContactAccount' => [
            'application/json',
        ],
        'unlockContactAccountResource' => [
            'application/json',
        ],
        'unlockCustomer' => [
            'application/json',
        ],
        'unlockSupplier' => [
            'application/json',
        ],
        'updateContactAccount' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'updateContactAccountBankDetails' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'updateContactAccountContact' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'updateContactAccountMainContact' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'updateContactAccountRelatedContacts' => [
            'application/json',
            'text/json',
            'application/*+json',
        ],
    ];

    /**
     * @param ClientInterface|null $client
     * @param Configuration|null   $config
     * @param HeaderSelector|null  $selector
     * @param int                  $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex(int $hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex(): int
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig(): Configuration
    {
        return $this->config;
    }

    /**
     * Operation addContactAccountContact
     *
     * Add related contacts
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addContactAccountContact'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return string
     */
    public function addContactAccountContact(
        string $contactAccountRef,
        ?\SynergiTech\Iplicit\Model\ContactUpdate $contactUpdate = null,
        string $contentType = self::contentTypes['addContactAccountContact'][0]
    ): string
    {
        list($response) = $this->addContactAccountContactWithHttpInfo($contactAccountRef, $contactUpdate, $contentType);
        return $response;
    }

    /**
     * Operation addContactAccountContactWithHttpInfo
     *
     * Add related contacts
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addContactAccountContact'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function addContactAccountContactWithHttpInfo(
        string $contactAccountRef,
        ?\SynergiTech\Iplicit\Model\ContactUpdate $contactUpdate = null,
        string $contentType = self::contentTypes['addContactAccountContact'][0]
    ): array
    {
        $request = $this->addContactAccountContactRequest($contactAccountRef, $contactUpdate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if (in_array('string', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addContactAccountContactAsync
     *
     * Add related contacts
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addContactAccountContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addContactAccountContactAsync(
        string $contactAccountRef,
        ?\SynergiTech\Iplicit\Model\ContactUpdate $contactUpdate = null,
        string $contentType = self::contentTypes['addContactAccountContact'][0]
    ): PromiseInterface
    {
        return $this->addContactAccountContactAsyncWithHttpInfo($contactAccountRef, $contactUpdate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addContactAccountContactAsyncWithHttpInfo
     *
     * Add related contacts
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addContactAccountContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addContactAccountContactAsyncWithHttpInfo(
        $contactAccountRef,
        $contactUpdate = null,
        string $contentType = self::contentTypes['addContactAccountContact'][0]
    ): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->addContactAccountContactRequest($contactAccountRef, $contactUpdate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addContactAccountContact'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addContactAccountContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addContactAccountContactRequest(
        $contactAccountRef,
        $contactUpdate = null,
        string $contentType = self::contentTypes['addContactAccountContact'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling addContactAccountContact'
            );
        }



        $resourcePath = '/api/ContactAccount/{contactAccountRef}/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($contactUpdate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($contactUpdate));
            } else {
                $httpBody = $contactUpdate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addContactToContactAccount
     *
     * Add an existing contact to a contact account.
     *
     * @param  string $ca contact account id or code (required)
     * @param  string $cb contact id or intRef (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addContactToContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function addContactToContactAccount(
        string $ca,
        string $cb,
        string $contentType = self::contentTypes['addContactToContactAccount'][0]
    ): void
    {
        $this->addContactToContactAccountWithHttpInfo($ca, $cb, $contentType);
    }

    /**
     * Operation addContactToContactAccountWithHttpInfo
     *
     * Add an existing contact to a contact account.
     *
     * @param  string $ca contact account id or code (required)
     * @param  string $cb contact id or intRef (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addContactToContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addContactToContactAccountWithHttpInfo(
        string $ca,
        string $cb,
        string $contentType = self::contentTypes['addContactToContactAccount'][0]
    ): array
    {
        $request = $this->addContactToContactAccountRequest($ca, $cb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation addContactToContactAccountAsync
     *
     * Add an existing contact to a contact account.
     *
     * @param  string $ca contact account id or code (required)
     * @param  string $cb contact id or intRef (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addContactToContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addContactToContactAccountAsync(
        string $ca,
        string $cb,
        string $contentType = self::contentTypes['addContactToContactAccount'][0]
    ): PromiseInterface
    {
        return $this->addContactToContactAccountAsyncWithHttpInfo($ca, $cb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addContactToContactAccountAsyncWithHttpInfo
     *
     * Add an existing contact to a contact account.
     *
     * @param  string $ca contact account id or code (required)
     * @param  string $cb contact id or intRef (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addContactToContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function addContactToContactAccountAsyncWithHttpInfo(
        $ca,
        $cb,
        string $contentType = self::contentTypes['addContactToContactAccount'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->addContactToContactAccountRequest($ca, $cb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addContactToContactAccount'
     *
     * @param  string $ca contact account id or code (required)
     * @param  string $cb contact id or intRef (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addContactToContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addContactToContactAccountRequest(
        $ca,
        $cb,
        string $contentType = self::contentTypes['addContactToContactAccount'][0]
    ): Request
    {

        // verify the required parameter 'ca' is set
        if ($ca === null || (is_array($ca) && count($ca) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $ca when calling addContactToContactAccount'
            );
        }

        // verify the required parameter 'cb' is set
        if ($cb === null || (is_array($cb) && count($cb) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $cb when calling addContactToContactAccount'
            );
        }


        $resourcePath = '/api/ContactAccount/{ca}/contactLinks/{cb}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($ca !== null) {
            $resourcePath = str_replace(
                '{' . 'ca' . '}',
                ObjectSerializer::toPathValue($ca),
                $resourcePath
            );
        }
        // path params
        if ($cb !== null) {
            $resourcePath = str_replace(
                '{' . 'cb' . '}',
                ObjectSerializer::toPathValue($cb),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createContactAccount
     *
     * Create a contact account
     *
     * @param  \SynergiTech\Iplicit\Model\ContactAccountCreate|null $contactAccountCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return string
     */
    public function createContactAccount(
        ?\SynergiTech\Iplicit\Model\ContactAccountCreate $contactAccountCreate = null,
        string $contentType = self::contentTypes['createContactAccount'][0]
    ): string
    {
        list($response) = $this->createContactAccountWithHttpInfo($contactAccountCreate, $contentType);
        return $response;
    }

    /**
     * Operation createContactAccountWithHttpInfo
     *
     * Create a contact account
     *
     * @param  \SynergiTech\Iplicit\Model\ContactAccountCreate|null $contactAccountCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function createContactAccountWithHttpInfo(
        ?\SynergiTech\Iplicit\Model\ContactAccountCreate $contactAccountCreate = null,
        string $contentType = self::contentTypes['createContactAccount'][0]
    ): array
    {
        $request = $this->createContactAccountRequest($contactAccountCreate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('string', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createContactAccountAsync
     *
     * Create a contact account
     *
     * @param  \SynergiTech\Iplicit\Model\ContactAccountCreate|null $contactAccountCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createContactAccountAsync(
        ?\SynergiTech\Iplicit\Model\ContactAccountCreate $contactAccountCreate = null,
        string $contentType = self::contentTypes['createContactAccount'][0]
    ): PromiseInterface
    {
        return $this->createContactAccountAsyncWithHttpInfo($contactAccountCreate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createContactAccountAsyncWithHttpInfo
     *
     * Create a contact account
     *
     * @param  \SynergiTech\Iplicit\Model\ContactAccountCreate|null $contactAccountCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function createContactAccountAsyncWithHttpInfo(
        $contactAccountCreate = null,
        string $contentType = self::contentTypes['createContactAccount'][0]
    ): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->createContactAccountRequest($contactAccountCreate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createContactAccount'
     *
     * @param  \SynergiTech\Iplicit\Model\ContactAccountCreate|null $contactAccountCreate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createContactAccountRequest(
        $contactAccountCreate = null,
        string $contentType = self::contentTypes['createContactAccount'][0]
    ): Request
    {



        $resourcePath = '/api/ContactAccount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($contactAccountCreate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($contactAccountCreate));
            } else {
                $httpBody = $contactAccountCreate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteContactAccount
     *
     * Delete a related contact
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteContactAccount(
        string $contactAccountRef,
        string $contactRef,
        string $contentType = self::contentTypes['deleteContactAccount'][0]
    ): void
    {
        $this->deleteContactAccountWithHttpInfo($contactAccountRef, $contactRef, $contentType);
    }

    /**
     * Operation deleteContactAccountWithHttpInfo
     *
     * Delete a related contact
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContactAccountWithHttpInfo(
        string $contactAccountRef,
        string $contactRef,
        string $contentType = self::contentTypes['deleteContactAccount'][0]
    ): array
    {
        $request = $this->deleteContactAccountRequest($contactAccountRef, $contactRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteContactAccountAsync
     *
     * Delete a related contact
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteContactAccountAsync(
        string $contactAccountRef,
        string $contactRef,
        string $contentType = self::contentTypes['deleteContactAccount'][0]
    ): PromiseInterface
    {
        return $this->deleteContactAccountAsyncWithHttpInfo($contactAccountRef, $contactRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteContactAccountAsyncWithHttpInfo
     *
     * Delete a related contact
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteContactAccountAsyncWithHttpInfo(
        $contactAccountRef,
        $contactRef,
        string $contentType = self::contentTypes['deleteContactAccount'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteContactAccountRequest($contactAccountRef, $contactRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteContactAccount'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteContactAccountRequest(
        $contactAccountRef,
        $contactRef,
        string $contentType = self::contentTypes['deleteContactAccount'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling deleteContactAccount'
            );
        }

        // verify the required parameter 'contactRef' is set
        if ($contactRef === null || (is_array($contactRef) && count($contactRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactRef when calling deleteContactAccount'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/contacts/{contactRef}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }
        // path params
        if ($contactRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactRef' . '}',
                ObjectSerializer::toPathValue($contactRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteContactFromContactAccount
     *
     * Remove an existing contact from a contact account.
     *
     * @param  string $ca Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $cb Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactFromContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function deleteContactFromContactAccount(
        string $ca,
        string $cb,
        string $contentType = self::contentTypes['deleteContactFromContactAccount'][0]
    ): void
    {
        $this->deleteContactFromContactAccountWithHttpInfo($ca, $cb, $contentType);
    }

    /**
     * Operation deleteContactFromContactAccountWithHttpInfo
     *
     * Remove an existing contact from a contact account.
     *
     * @param  string $ca Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $cb Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactFromContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteContactFromContactAccountWithHttpInfo(
        string $ca,
        string $cb,
        string $contentType = self::contentTypes['deleteContactFromContactAccount'][0]
    ): array
    {
        $request = $this->deleteContactFromContactAccountRequest($ca, $cb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteContactFromContactAccountAsync
     *
     * Remove an existing contact from a contact account.
     *
     * @param  string $ca Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $cb Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactFromContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteContactFromContactAccountAsync(
        string $ca,
        string $cb,
        string $contentType = self::contentTypes['deleteContactFromContactAccount'][0]
    ): PromiseInterface
    {
        return $this->deleteContactFromContactAccountAsyncWithHttpInfo($ca, $cb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteContactFromContactAccountAsyncWithHttpInfo
     *
     * Remove an existing contact from a contact account.
     *
     * @param  string $ca Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $cb Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactFromContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function deleteContactFromContactAccountAsyncWithHttpInfo(
        $ca,
        $cb,
        string $contentType = self::contentTypes['deleteContactFromContactAccount'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->deleteContactFromContactAccountRequest($ca, $cb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteContactFromContactAccount'
     *
     * @param  string $ca Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $cb Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteContactFromContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteContactFromContactAccountRequest(
        $ca,
        $cb,
        string $contentType = self::contentTypes['deleteContactFromContactAccount'][0]
    ): Request
    {

        // verify the required parameter 'ca' is set
        if ($ca === null || (is_array($ca) && count($ca) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $ca when calling deleteContactFromContactAccount'
            );
        }

        // verify the required parameter 'cb' is set
        if ($cb === null || (is_array($cb) && count($cb) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $cb when calling deleteContactFromContactAccount'
            );
        }


        $resourcePath = '/api/ContactAccount/{ca}/contactLinks/{cb}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($ca !== null) {
            $resourcePath = str_replace(
                '{' . 'ca' . '}',
                ObjectSerializer::toPathValue($ca),
                $resourcePath
            );
        }
        // path params
        if ($cb !== null) {
            $resourcePath = str_replace(
                '{' . 'cb' . '}',
                ObjectSerializer::toPathValue($cb),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactAccount
     *
     * Get a contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string|null $include Comma separated list of detail notes to include. Permitted values are &#x60;customer&#x60;, &#x60;supplier&#x60;, &#x60;resource&#x60;, &#x60;contact&#x60;, &#x60;contacts&#x60;, &#x60;defaultBankDetails&#x60;, &#x60;allBankDetails&#x60;. Default is &#x60;customer,supplier&#x60;. (optional, default to 'customer,supplier')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Iplicit\Model\ContactAccountRead
     */
    public function getContactAccount(
        string $contactAccountRef,
        ?string $include = 'customer,supplier',
        string $contentType = self::contentTypes['getContactAccount'][0]
    ): \SynergiTech\Iplicit\Model\ContactAccountRead
    {
        list($response) = $this->getContactAccountWithHttpInfo($contactAccountRef, $include, $contentType);
        return $response;
    }

    /**
     * Operation getContactAccountWithHttpInfo
     *
     * Get a contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string|null $include Comma separated list of detail notes to include. Permitted values are &#x60;customer&#x60;, &#x60;supplier&#x60;, &#x60;resource&#x60;, &#x60;contact&#x60;, &#x60;contacts&#x60;, &#x60;defaultBankDetails&#x60;, &#x60;allBankDetails&#x60;. Default is &#x60;customer,supplier&#x60;. (optional, default to 'customer,supplier')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Iplicit\Model\ContactAccountRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAccountWithHttpInfo(
        string $contactAccountRef,
        ?string $include = 'customer,supplier',
        string $contentType = self::contentTypes['getContactAccount'][0]
    ): array
    {
        $request = $this->getContactAccountRequest($contactAccountRef, $include, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Iplicit\Model\ContactAccountRead', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Iplicit\Model\ContactAccountRead' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Iplicit\Model\ContactAccountRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SynergiTech\Iplicit\Model\ContactAccountRead';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Iplicit\Model\ContactAccountRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAccountAsync
     *
     * Get a contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string|null $include Comma separated list of detail notes to include. Permitted values are &#x60;customer&#x60;, &#x60;supplier&#x60;, &#x60;resource&#x60;, &#x60;contact&#x60;, &#x60;contacts&#x60;, &#x60;defaultBankDetails&#x60;, &#x60;allBankDetails&#x60;. Default is &#x60;customer,supplier&#x60;. (optional, default to 'customer,supplier')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountAsync(
        string $contactAccountRef,
        ?string $include = 'customer,supplier',
        string $contentType = self::contentTypes['getContactAccount'][0]
    ): PromiseInterface
    {
        return $this->getContactAccountAsyncWithHttpInfo($contactAccountRef, $include, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAccountAsyncWithHttpInfo
     *
     * Get a contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string|null $include Comma separated list of detail notes to include. Permitted values are &#x60;customer&#x60;, &#x60;supplier&#x60;, &#x60;resource&#x60;, &#x60;contact&#x60;, &#x60;contacts&#x60;, &#x60;defaultBankDetails&#x60;, &#x60;allBankDetails&#x60;. Default is &#x60;customer,supplier&#x60;. (optional, default to 'customer,supplier')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountAsyncWithHttpInfo(
        $contactAccountRef,
        $include = 'customer,supplier',
        string $contentType = self::contentTypes['getContactAccount'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Iplicit\Model\ContactAccountRead';
        $request = $this->getContactAccountRequest($contactAccountRef, $include, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactAccount'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string|null $include Comma separated list of detail notes to include. Permitted values are &#x60;customer&#x60;, &#x60;supplier&#x60;, &#x60;resource&#x60;, &#x60;contact&#x60;, &#x60;contacts&#x60;, &#x60;defaultBankDetails&#x60;, &#x60;allBankDetails&#x60;. Default is &#x60;customer,supplier&#x60;. (optional, default to 'customer,supplier')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactAccountRequest(
        $contactAccountRef,
        $include = 'customer,supplier',
        string $contentType = self::contentTypes['getContactAccount'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling getContactAccount'
            );
        }



        $resourcePath = '/api/ContactAccount/{contactAccountRef}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include,
            'include', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactAccountBankAccounts
     *
     * Get all the bank details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountBankAccounts'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Iplicit\Model\ContactBankDetailsRead[]
     */
    public function getContactAccountBankAccounts(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountBankAccounts'][0]
    ): array
    {
        list($response) = $this->getContactAccountBankAccountsWithHttpInfo($contactAccountRef, $contentType);
        return $response;
    }

    /**
     * Operation getContactAccountBankAccountsWithHttpInfo
     *
     * Get all the bank details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountBankAccounts'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Iplicit\Model\ContactBankDetailsRead[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAccountBankAccountsWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountBankAccounts'][0]
    ): array
    {
        $request = $this->getContactAccountBankAccountsRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Iplicit\Model\ContactBankDetailsRead[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Iplicit\Model\ContactBankDetailsRead[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Iplicit\Model\ContactBankDetailsRead[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SynergiTech\Iplicit\Model\ContactBankDetailsRead[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Iplicit\Model\ContactBankDetailsRead[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAccountBankAccountsAsync
     *
     * Get all the bank details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountBankAccounts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountBankAccountsAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountBankAccounts'][0]
    ): PromiseInterface
    {
        return $this->getContactAccountBankAccountsAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAccountBankAccountsAsyncWithHttpInfo
     *
     * Get all the bank details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountBankAccounts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountBankAccountsAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountBankAccounts'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Iplicit\Model\ContactBankDetailsRead[]';
        $request = $this->getContactAccountBankAccountsRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactAccountBankAccounts'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountBankAccounts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactAccountBankAccountsRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountBankAccounts'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling getContactAccountBankAccounts'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/bankDetails';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactAccountCustomerDetails
     *
     * Get the customer details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountCustomerDetails'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Iplicit\Model\ContactCustomerRead
     */
    public function getContactAccountCustomerDetails(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountCustomerDetails'][0]
    ): \SynergiTech\Iplicit\Model\ContactCustomerRead
    {
        list($response) = $this->getContactAccountCustomerDetailsWithHttpInfo($contactAccountRef, $contentType);
        return $response;
    }

    /**
     * Operation getContactAccountCustomerDetailsWithHttpInfo
     *
     * Get the customer details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountCustomerDetails'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Iplicit\Model\ContactCustomerRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAccountCustomerDetailsWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountCustomerDetails'][0]
    ): array
    {
        $request = $this->getContactAccountCustomerDetailsRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Iplicit\Model\ContactCustomerRead', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Iplicit\Model\ContactCustomerRead' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Iplicit\Model\ContactCustomerRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SynergiTech\Iplicit\Model\ContactCustomerRead';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Iplicit\Model\ContactCustomerRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAccountCustomerDetailsAsync
     *
     * Get the customer details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountCustomerDetails'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountCustomerDetailsAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountCustomerDetails'][0]
    ): PromiseInterface
    {
        return $this->getContactAccountCustomerDetailsAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAccountCustomerDetailsAsyncWithHttpInfo
     *
     * Get the customer details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountCustomerDetails'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountCustomerDetailsAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountCustomerDetails'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Iplicit\Model\ContactCustomerRead';
        $request = $this->getContactAccountCustomerDetailsRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactAccountCustomerDetails'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountCustomerDetails'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactAccountCustomerDetailsRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountCustomerDetails'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling getContactAccountCustomerDetails'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/customer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactAccountDefaultBankAccount
     *
     * Get the default bank details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountDefaultBankAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Iplicit\Model\ContactBankDetailsRead
     */
    public function getContactAccountDefaultBankAccount(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountDefaultBankAccount'][0]
    ): \SynergiTech\Iplicit\Model\ContactBankDetailsRead
    {
        list($response) = $this->getContactAccountDefaultBankAccountWithHttpInfo($contactAccountRef, $contentType);
        return $response;
    }

    /**
     * Operation getContactAccountDefaultBankAccountWithHttpInfo
     *
     * Get the default bank details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountDefaultBankAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Iplicit\Model\ContactBankDetailsRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAccountDefaultBankAccountWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountDefaultBankAccount'][0]
    ): array
    {
        $request = $this->getContactAccountDefaultBankAccountRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Iplicit\Model\ContactBankDetailsRead', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Iplicit\Model\ContactBankDetailsRead' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Iplicit\Model\ContactBankDetailsRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SynergiTech\Iplicit\Model\ContactBankDetailsRead';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Iplicit\Model\ContactBankDetailsRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAccountDefaultBankAccountAsync
     *
     * Get the default bank details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountDefaultBankAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountDefaultBankAccountAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountDefaultBankAccount'][0]
    ): PromiseInterface
    {
        return $this->getContactAccountDefaultBankAccountAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAccountDefaultBankAccountAsyncWithHttpInfo
     *
     * Get the default bank details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountDefaultBankAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountDefaultBankAccountAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountDefaultBankAccount'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Iplicit\Model\ContactBankDetailsRead';
        $request = $this->getContactAccountDefaultBankAccountRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactAccountDefaultBankAccount'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountDefaultBankAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactAccountDefaultBankAccountRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountDefaultBankAccount'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling getContactAccountDefaultBankAccount'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/defaultBankDetails';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactAccountMainContact
     *
     * Get the main contact details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountMainContact'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Iplicit\Model\ContactRead
     */
    public function getContactAccountMainContact(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountMainContact'][0]
    ): \SynergiTech\Iplicit\Model\ContactRead
    {
        list($response) = $this->getContactAccountMainContactWithHttpInfo($contactAccountRef, $contentType);
        return $response;
    }

    /**
     * Operation getContactAccountMainContactWithHttpInfo
     *
     * Get the main contact details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountMainContact'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Iplicit\Model\ContactRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAccountMainContactWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountMainContact'][0]
    ): array
    {
        $request = $this->getContactAccountMainContactRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Iplicit\Model\ContactRead', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Iplicit\Model\ContactRead' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Iplicit\Model\ContactRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SynergiTech\Iplicit\Model\ContactRead';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Iplicit\Model\ContactRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAccountMainContactAsync
     *
     * Get the main contact details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountMainContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountMainContactAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountMainContact'][0]
    ): PromiseInterface
    {
        return $this->getContactAccountMainContactAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAccountMainContactAsyncWithHttpInfo
     *
     * Get the main contact details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountMainContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountMainContactAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountMainContact'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Iplicit\Model\ContactRead';
        $request = $this->getContactAccountMainContactRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactAccountMainContact'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountMainContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactAccountMainContactRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountMainContact'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling getContactAccountMainContact'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/contact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactAccountRelatedContact
     *
     * Get an existing related contact
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountRelatedContact'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Iplicit\Model\ContactRead
     */
    public function getContactAccountRelatedContact(
        string $contactAccountRef,
        string $contactRef,
        string $contentType = self::contentTypes['getContactAccountRelatedContact'][0]
    ): \SynergiTech\Iplicit\Model\ContactRead
    {
        list($response) = $this->getContactAccountRelatedContactWithHttpInfo($contactAccountRef, $contactRef, $contentType);
        return $response;
    }

    /**
     * Operation getContactAccountRelatedContactWithHttpInfo
     *
     * Get an existing related contact
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountRelatedContact'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Iplicit\Model\ContactRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAccountRelatedContactWithHttpInfo(
        string $contactAccountRef,
        string $contactRef,
        string $contentType = self::contentTypes['getContactAccountRelatedContact'][0]
    ): array
    {
        $request = $this->getContactAccountRelatedContactRequest($contactAccountRef, $contactRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Iplicit\Model\ContactRead', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Iplicit\Model\ContactRead' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Iplicit\Model\ContactRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SynergiTech\Iplicit\Model\ContactRead';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Iplicit\Model\ContactRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAccountRelatedContactAsync
     *
     * Get an existing related contact
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountRelatedContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountRelatedContactAsync(
        string $contactAccountRef,
        string $contactRef,
        string $contentType = self::contentTypes['getContactAccountRelatedContact'][0]
    ): PromiseInterface
    {
        return $this->getContactAccountRelatedContactAsyncWithHttpInfo($contactAccountRef, $contactRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAccountRelatedContactAsyncWithHttpInfo
     *
     * Get an existing related contact
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountRelatedContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountRelatedContactAsyncWithHttpInfo(
        $contactAccountRef,
        $contactRef,
        string $contentType = self::contentTypes['getContactAccountRelatedContact'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Iplicit\Model\ContactRead';
        $request = $this->getContactAccountRelatedContactRequest($contactAccountRef, $contactRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactAccountRelatedContact'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountRelatedContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactAccountRelatedContactRequest(
        $contactAccountRef,
        $contactRef,
        string $contentType = self::contentTypes['getContactAccountRelatedContact'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling getContactAccountRelatedContact'
            );
        }

        // verify the required parameter 'contactRef' is set
        if ($contactRef === null || (is_array($contactRef) && count($contactRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactRef when calling getContactAccountRelatedContact'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/contacts/{contactRef}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }
        // path params
        if ($contactRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactRef' . '}',
                ObjectSerializer::toPathValue($contactRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactAccountRelatedContacts
     *
     * Get the related contacts
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountRelatedContacts'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Iplicit\Model\ContactRead[]
     */
    public function getContactAccountRelatedContacts(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountRelatedContacts'][0]
    ): array
    {
        list($response) = $this->getContactAccountRelatedContactsWithHttpInfo($contactAccountRef, $contentType);
        return $response;
    }

    /**
     * Operation getContactAccountRelatedContactsWithHttpInfo
     *
     * Get the related contacts
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountRelatedContacts'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Iplicit\Model\ContactRead[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAccountRelatedContactsWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountRelatedContacts'][0]
    ): array
    {
        $request = $this->getContactAccountRelatedContactsRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Iplicit\Model\ContactRead[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Iplicit\Model\ContactRead[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Iplicit\Model\ContactRead[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SynergiTech\Iplicit\Model\ContactRead[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Iplicit\Model\ContactRead[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAccountRelatedContactsAsync
     *
     * Get the related contacts
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountRelatedContacts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountRelatedContactsAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountRelatedContacts'][0]
    ): PromiseInterface
    {
        return $this->getContactAccountRelatedContactsAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAccountRelatedContactsAsyncWithHttpInfo
     *
     * Get the related contacts
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountRelatedContacts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountRelatedContactsAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountRelatedContacts'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Iplicit\Model\ContactRead[]';
        $request = $this->getContactAccountRelatedContactsRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactAccountRelatedContacts'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountRelatedContacts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactAccountRelatedContactsRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountRelatedContacts'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling getContactAccountRelatedContacts'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactAccountResource
     *
     * Get the resource details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountResource'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Iplicit\Model\ContactResourceRead
     */
    public function getContactAccountResource(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountResource'][0]
    ): \SynergiTech\Iplicit\Model\ContactResourceRead
    {
        list($response) = $this->getContactAccountResourceWithHttpInfo($contactAccountRef, $contentType);
        return $response;
    }

    /**
     * Operation getContactAccountResourceWithHttpInfo
     *
     * Get the resource details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountResource'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Iplicit\Model\ContactResourceRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAccountResourceWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountResource'][0]
    ): array
    {
        $request = $this->getContactAccountResourceRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Iplicit\Model\ContactResourceRead', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Iplicit\Model\ContactResourceRead' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Iplicit\Model\ContactResourceRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SynergiTech\Iplicit\Model\ContactResourceRead';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Iplicit\Model\ContactResourceRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAccountResourceAsync
     *
     * Get the resource details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountResource'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountResourceAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountResource'][0]
    ): PromiseInterface
    {
        return $this->getContactAccountResourceAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAccountResourceAsyncWithHttpInfo
     *
     * Get the resource details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountResource'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountResourceAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountResource'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Iplicit\Model\ContactResourceRead';
        $request = $this->getContactAccountResourceRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactAccountResource'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountResource'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactAccountResourceRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountResource'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling getContactAccountResource'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/resource';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactAccountSupplierDefaults
     *
     * Get the supplier details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountSupplierDefaults'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Iplicit\Model\ContactSupplierRead
     */
    public function getContactAccountSupplierDefaults(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountSupplierDefaults'][0]
    ): \SynergiTech\Iplicit\Model\ContactSupplierRead
    {
        list($response) = $this->getContactAccountSupplierDefaultsWithHttpInfo($contactAccountRef, $contentType);
        return $response;
    }

    /**
     * Operation getContactAccountSupplierDefaultsWithHttpInfo
     *
     * Get the supplier details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountSupplierDefaults'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Iplicit\Model\ContactSupplierRead, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAccountSupplierDefaultsWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountSupplierDefaults'][0]
    ): array
    {
        $request = $this->getContactAccountSupplierDefaultsRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Iplicit\Model\ContactSupplierRead', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Iplicit\Model\ContactSupplierRead' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Iplicit\Model\ContactSupplierRead', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SynergiTech\Iplicit\Model\ContactSupplierRead';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Iplicit\Model\ContactSupplierRead',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAccountSupplierDefaultsAsync
     *
     * Get the supplier details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountSupplierDefaults'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountSupplierDefaultsAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountSupplierDefaults'][0]
    ): PromiseInterface
    {
        return $this->getContactAccountSupplierDefaultsAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAccountSupplierDefaultsAsyncWithHttpInfo
     *
     * Get the supplier details of the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountSupplierDefaults'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountSupplierDefaultsAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountSupplierDefaults'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Iplicit\Model\ContactSupplierRead';
        $request = $this->getContactAccountSupplierDefaultsRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactAccountSupplierDefaults'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccountSupplierDefaults'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactAccountSupplierDefaultsRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['getContactAccountSupplierDefaults'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling getContactAccountSupplierDefaults'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/supplier';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContactAccounts
     *
     * Gets a list of contact accounts with a search filter
     *
     * @param  string|null $code Code. &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;Learn more&lt;/a&gt; (optional)
     * @param  string|null $intRef Optional interface reference. If provided, it must be unique. &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;Learn more&lt;/a&gt; (optional)
     * @param  string|null $descriptionContains Description contains (optional)
     * @param  \DateTime|null $lastModifiedFrom Last modified from (UTC) (optional)
     * @param  \DateTime|null $lastModifiedTo Last modified until (UTC) (optional)
     * @param  bool|null $isCustomer Include/exclude customers (optional)
     * @param  bool|null $isSupplier Include/exclude suppliers (optional)
     * @param  bool|null $isResource Include/exclude resources (optional)
     * @param  string|null $include Comma separated list of detail notes to include: &#x60;customer&#x60;, &#x60;supplier&#x60;, &#x60;resource&#x60;, &#x60;contact&#x60;, &#x60;contacts&#x60;, &#x60;defaultBankDetails&#x60;, &#x60;allBankDetails&#x60;. If omitted, will default to &#x60;customer,supplier&#x60;. (optional, default to 'customer,supplier')
     * @param  int|null $take The number of records to return (optional, default to 100)
     * @param  int|null $skip The number of records to skip (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccounts'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return \SynergiTech\Iplicit\Model\ContactAccountRead[]
     */
    public function getContactAccounts(
        ?string $code = null,
        ?string $intRef = null,
        ?string $descriptionContains = null,
        ?\DateTime $lastModifiedFrom = null,
        ?\DateTime $lastModifiedTo = null,
        ?bool $isCustomer = null,
        ?bool $isSupplier = null,
        ?bool $isResource = null,
        ?string $include = 'customer,supplier',
        ?int $take = 100,
        ?int $skip = 0,
        string $contentType = self::contentTypes['getContactAccounts'][0]
    ): array
    {
        list($response) = $this->getContactAccountsWithHttpInfo($code, $intRef, $descriptionContains, $lastModifiedFrom, $lastModifiedTo, $isCustomer, $isSupplier, $isResource, $include, $take, $skip, $contentType);
        return $response;
    }

    /**
     * Operation getContactAccountsWithHttpInfo
     *
     * Gets a list of contact accounts with a search filter
     *
     * @param  string|null $code Code. &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;Learn more&lt;/a&gt; (optional)
     * @param  string|null $intRef Optional interface reference. If provided, it must be unique. &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;Learn more&lt;/a&gt; (optional)
     * @param  string|null $descriptionContains Description contains (optional)
     * @param  \DateTime|null $lastModifiedFrom Last modified from (UTC) (optional)
     * @param  \DateTime|null $lastModifiedTo Last modified until (UTC) (optional)
     * @param  bool|null $isCustomer Include/exclude customers (optional)
     * @param  bool|null $isSupplier Include/exclude suppliers (optional)
     * @param  bool|null $isResource Include/exclude resources (optional)
     * @param  string|null $include Comma separated list of detail notes to include: &#x60;customer&#x60;, &#x60;supplier&#x60;, &#x60;resource&#x60;, &#x60;contact&#x60;, &#x60;contacts&#x60;, &#x60;defaultBankDetails&#x60;, &#x60;allBankDetails&#x60;. If omitted, will default to &#x60;customer,supplier&#x60;. (optional, default to 'customer,supplier')
     * @param  int|null $take The number of records to return (optional, default to 100)
     * @param  int|null $skip The number of records to skip (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccounts'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of \SynergiTech\Iplicit\Model\ContactAccountRead[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getContactAccountsWithHttpInfo(
        ?string $code = null,
        ?string $intRef = null,
        ?string $descriptionContains = null,
        ?\DateTime $lastModifiedFrom = null,
        ?\DateTime $lastModifiedTo = null,
        ?bool $isCustomer = null,
        ?bool $isSupplier = null,
        ?bool $isResource = null,
        ?string $include = 'customer,supplier',
        ?int $take = 100,
        ?int $skip = 0,
        string $contentType = self::contentTypes['getContactAccounts'][0]
    ): array
    {
        $request = $this->getContactAccountsRequest($code, $intRef, $descriptionContains, $lastModifiedFrom, $lastModifiedTo, $isCustomer, $isSupplier, $isResource, $include, $take, $skip, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('\SynergiTech\Iplicit\Model\ContactAccountRead[]', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\SynergiTech\Iplicit\Model\ContactAccountRead[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SynergiTech\Iplicit\Model\ContactAccountRead[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SynergiTech\Iplicit\Model\ContactAccountRead[]';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SynergiTech\Iplicit\Model\ContactAccountRead[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContactAccountsAsync
     *
     * Gets a list of contact accounts with a search filter
     *
     * @param  string|null $code Code. &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;Learn more&lt;/a&gt; (optional)
     * @param  string|null $intRef Optional interface reference. If provided, it must be unique. &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;Learn more&lt;/a&gt; (optional)
     * @param  string|null $descriptionContains Description contains (optional)
     * @param  \DateTime|null $lastModifiedFrom Last modified from (UTC) (optional)
     * @param  \DateTime|null $lastModifiedTo Last modified until (UTC) (optional)
     * @param  bool|null $isCustomer Include/exclude customers (optional)
     * @param  bool|null $isSupplier Include/exclude suppliers (optional)
     * @param  bool|null $isResource Include/exclude resources (optional)
     * @param  string|null $include Comma separated list of detail notes to include: &#x60;customer&#x60;, &#x60;supplier&#x60;, &#x60;resource&#x60;, &#x60;contact&#x60;, &#x60;contacts&#x60;, &#x60;defaultBankDetails&#x60;, &#x60;allBankDetails&#x60;. If omitted, will default to &#x60;customer,supplier&#x60;. (optional, default to 'customer,supplier')
     * @param  int|null $take The number of records to return (optional, default to 100)
     * @param  int|null $skip The number of records to skip (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccounts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountsAsync(
        ?string $code = null,
        ?string $intRef = null,
        ?string $descriptionContains = null,
        ?\DateTime $lastModifiedFrom = null,
        ?\DateTime $lastModifiedTo = null,
        ?bool $isCustomer = null,
        ?bool $isSupplier = null,
        ?bool $isResource = null,
        ?string $include = 'customer,supplier',
        ?int $take = 100,
        ?int $skip = 0,
        string $contentType = self::contentTypes['getContactAccounts'][0]
    ): PromiseInterface
    {
        return $this->getContactAccountsAsyncWithHttpInfo($code, $intRef, $descriptionContains, $lastModifiedFrom, $lastModifiedTo, $isCustomer, $isSupplier, $isResource, $include, $take, $skip, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContactAccountsAsyncWithHttpInfo
     *
     * Gets a list of contact accounts with a search filter
     *
     * @param  string|null $code Code. &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;Learn more&lt;/a&gt; (optional)
     * @param  string|null $intRef Optional interface reference. If provided, it must be unique. &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;Learn more&lt;/a&gt; (optional)
     * @param  string|null $descriptionContains Description contains (optional)
     * @param  \DateTime|null $lastModifiedFrom Last modified from (UTC) (optional)
     * @param  \DateTime|null $lastModifiedTo Last modified until (UTC) (optional)
     * @param  bool|null $isCustomer Include/exclude customers (optional)
     * @param  bool|null $isSupplier Include/exclude suppliers (optional)
     * @param  bool|null $isResource Include/exclude resources (optional)
     * @param  string|null $include Comma separated list of detail notes to include: &#x60;customer&#x60;, &#x60;supplier&#x60;, &#x60;resource&#x60;, &#x60;contact&#x60;, &#x60;contacts&#x60;, &#x60;defaultBankDetails&#x60;, &#x60;allBankDetails&#x60;. If omitted, will default to &#x60;customer,supplier&#x60;. (optional, default to 'customer,supplier')
     * @param  int|null $take The number of records to return (optional, default to 100)
     * @param  int|null $skip The number of records to skip (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccounts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function getContactAccountsAsyncWithHttpInfo(
        $code = null,
        $intRef = null,
        $descriptionContains = null,
        $lastModifiedFrom = null,
        $lastModifiedTo = null,
        $isCustomer = null,
        $isSupplier = null,
        $isResource = null,
        $include = 'customer,supplier',
        $take = 100,
        $skip = 0,
        string $contentType = self::contentTypes['getContactAccounts'][0]
    ): PromiseInterface
    {
        $returnType = '\SynergiTech\Iplicit\Model\ContactAccountRead[]';
        $request = $this->getContactAccountsRequest($code, $intRef, $descriptionContains, $lastModifiedFrom, $lastModifiedTo, $isCustomer, $isSupplier, $isResource, $include, $take, $skip, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContactAccounts'
     *
     * @param  string|null $code Code. &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;Learn more&lt;/a&gt; (optional)
     * @param  string|null $intRef Optional interface reference. If provided, it must be unique. &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;Learn more&lt;/a&gt; (optional)
     * @param  string|null $descriptionContains Description contains (optional)
     * @param  \DateTime|null $lastModifiedFrom Last modified from (UTC) (optional)
     * @param  \DateTime|null $lastModifiedTo Last modified until (UTC) (optional)
     * @param  bool|null $isCustomer Include/exclude customers (optional)
     * @param  bool|null $isSupplier Include/exclude suppliers (optional)
     * @param  bool|null $isResource Include/exclude resources (optional)
     * @param  string|null $include Comma separated list of detail notes to include: &#x60;customer&#x60;, &#x60;supplier&#x60;, &#x60;resource&#x60;, &#x60;contact&#x60;, &#x60;contacts&#x60;, &#x60;defaultBankDetails&#x60;, &#x60;allBankDetails&#x60;. If omitted, will default to &#x60;customer,supplier&#x60;. (optional, default to 'customer,supplier')
     * @param  int|null $take The number of records to return (optional, default to 100)
     * @param  int|null $skip The number of records to skip (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getContactAccounts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getContactAccountsRequest(
        $code = null,
        $intRef = null,
        $descriptionContains = null,
        $lastModifiedFrom = null,
        $lastModifiedTo = null,
        $isCustomer = null,
        $isSupplier = null,
        $isResource = null,
        $include = 'customer,supplier',
        $take = 100,
        $skip = 0,
        string $contentType = self::contentTypes['getContactAccounts'][0]
    ): Request
    {

        if ($code !== null && strlen($code) > 50) {
            throw new InvalidArgumentException('invalid length for "$code" when calling ContactAccountApi.getContactAccounts, must be smaller than or equal to 50.');
        }
        
        if ($intRef !== null && strlen($intRef) > 50) {
            throw new InvalidArgumentException('invalid length for "$intRef" when calling ContactAccountApi.getContactAccounts, must be smaller than or equal to 50.');
        }
        










        $resourcePath = '/api/ContactAccount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $code,
            'Code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $intRef,
            'IntRef', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $descriptionContains,
            'DescriptionContains', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lastModifiedFrom,
            'LastModifiedFrom', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $lastModifiedTo,
            'LastModifiedTo', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isCustomer,
            'IsCustomer', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isSupplier,
            'IsSupplier', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $isResource,
            'IsResource', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include,
            'include', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take,
            'take', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lockContactAccount
     *
     * @param  string $contactAccountRef contactAccountRef (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function lockContactAccount(
        string $contactAccountRef,
        string $contentType = self::contentTypes['lockContactAccount'][0]
    ): void
    {
        $this->lockContactAccountWithHttpInfo($contactAccountRef, $contentType);
    }

    /**
     * Operation lockContactAccountWithHttpInfo
     *
     * @param  string $contactAccountRef (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function lockContactAccountWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['lockContactAccount'][0]
    ): array
    {
        $request = $this->lockContactAccountRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation lockContactAccountAsync
     *
     * @param  string $contactAccountRef (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function lockContactAccountAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['lockContactAccount'][0]
    ): PromiseInterface
    {
        return $this->lockContactAccountAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lockContactAccountAsyncWithHttpInfo
     *
     * @param  string $contactAccountRef (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function lockContactAccountAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['lockContactAccount'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->lockContactAccountRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lockContactAccount'
     *
     * @param  string $contactAccountRef (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lockContactAccountRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['lockContactAccount'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling lockContactAccount'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lockContactAccountResource
     *
     * Lock the contact account resource
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockContactAccountResource'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function lockContactAccountResource(
        string $contactAccountRef,
        string $contentType = self::contentTypes['lockContactAccountResource'][0]
    ): void
    {
        $this->lockContactAccountResourceWithHttpInfo($contactAccountRef, $contentType);
    }

    /**
     * Operation lockContactAccountResourceWithHttpInfo
     *
     * Lock the contact account resource
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockContactAccountResource'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function lockContactAccountResourceWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['lockContactAccountResource'][0]
    ): array
    {
        $request = $this->lockContactAccountResourceRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation lockContactAccountResourceAsync
     *
     * Lock the contact account resource
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockContactAccountResource'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function lockContactAccountResourceAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['lockContactAccountResource'][0]
    ): PromiseInterface
    {
        return $this->lockContactAccountResourceAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lockContactAccountResourceAsyncWithHttpInfo
     *
     * Lock the contact account resource
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockContactAccountResource'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function lockContactAccountResourceAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['lockContactAccountResource'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->lockContactAccountResourceRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lockContactAccountResource'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockContactAccountResource'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lockContactAccountResourceRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['lockContactAccountResource'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling lockContactAccountResource'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/resource/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lockCustomer
     *
     * Lock the customer
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockCustomer'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function lockCustomer(
        string $contactAccountRef,
        string $contentType = self::contentTypes['lockCustomer'][0]
    ): void
    {
        $this->lockCustomerWithHttpInfo($contactAccountRef, $contentType);
    }

    /**
     * Operation lockCustomerWithHttpInfo
     *
     * Lock the customer
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockCustomer'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function lockCustomerWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['lockCustomer'][0]
    ): array
    {
        $request = $this->lockCustomerRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation lockCustomerAsync
     *
     * Lock the customer
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockCustomer'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function lockCustomerAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['lockCustomer'][0]
    ): PromiseInterface
    {
        return $this->lockCustomerAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lockCustomerAsyncWithHttpInfo
     *
     * Lock the customer
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockCustomer'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function lockCustomerAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['lockCustomer'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->lockCustomerRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lockCustomer'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockCustomer'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lockCustomerRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['lockCustomer'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling lockCustomer'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/customer/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lockSupplier
     *
     * Lock the supplier
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockSupplier'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function lockSupplier(
        string $contactAccountRef,
        string $contentType = self::contentTypes['lockSupplier'][0]
    ): void
    {
        $this->lockSupplierWithHttpInfo($contactAccountRef, $contentType);
    }

    /**
     * Operation lockSupplierWithHttpInfo
     *
     * Lock the supplier
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockSupplier'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function lockSupplierWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['lockSupplier'][0]
    ): array
    {
        $request = $this->lockSupplierRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation lockSupplierAsync
     *
     * Lock the supplier
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockSupplier'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function lockSupplierAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['lockSupplier'][0]
    ): PromiseInterface
    {
        return $this->lockSupplierAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lockSupplierAsyncWithHttpInfo
     *
     * Lock the supplier
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockSupplier'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function lockSupplierAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['lockSupplier'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->lockSupplierRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lockSupplier'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockSupplier'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lockSupplierRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['lockSupplier'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling lockSupplier'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/supplier/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlockContactAccount
     *
     * Unlock the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function unlockContactAccount(
        string $contactAccountRef,
        string $contentType = self::contentTypes['unlockContactAccount'][0]
    ): void
    {
        $this->unlockContactAccountWithHttpInfo($contactAccountRef, $contentType);
    }

    /**
     * Operation unlockContactAccountWithHttpInfo
     *
     * Unlock the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unlockContactAccountWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['unlockContactAccount'][0]
    ): array
    {
        $request = $this->unlockContactAccountRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation unlockContactAccountAsync
     *
     * Unlock the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unlockContactAccountAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['unlockContactAccount'][0]
    ): PromiseInterface
    {
        return $this->unlockContactAccountAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unlockContactAccountAsyncWithHttpInfo
     *
     * Unlock the contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unlockContactAccountAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['unlockContactAccount'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->unlockContactAccountRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unlockContactAccount'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unlockContactAccountRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['unlockContactAccount'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling unlockContactAccount'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/unlock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlockContactAccountResource
     *
     * Unlock the contact account resource
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockContactAccountResource'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function unlockContactAccountResource(
        string $contactAccountRef,
        string $contentType = self::contentTypes['unlockContactAccountResource'][0]
    ): void
    {
        $this->unlockContactAccountResourceWithHttpInfo($contactAccountRef, $contentType);
    }

    /**
     * Operation unlockContactAccountResourceWithHttpInfo
     *
     * Unlock the contact account resource
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockContactAccountResource'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unlockContactAccountResourceWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['unlockContactAccountResource'][0]
    ): array
    {
        $request = $this->unlockContactAccountResourceRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation unlockContactAccountResourceAsync
     *
     * Unlock the contact account resource
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockContactAccountResource'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unlockContactAccountResourceAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['unlockContactAccountResource'][0]
    ): PromiseInterface
    {
        return $this->unlockContactAccountResourceAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unlockContactAccountResourceAsyncWithHttpInfo
     *
     * Unlock the contact account resource
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockContactAccountResource'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unlockContactAccountResourceAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['unlockContactAccountResource'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->unlockContactAccountResourceRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unlockContactAccountResource'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockContactAccountResource'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unlockContactAccountResourceRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['unlockContactAccountResource'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling unlockContactAccountResource'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/resource/unlock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlockCustomer
     *
     * Unlock the customer
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockCustomer'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function unlockCustomer(
        string $contactAccountRef,
        string $contentType = self::contentTypes['unlockCustomer'][0]
    ): void
    {
        $this->unlockCustomerWithHttpInfo($contactAccountRef, $contentType);
    }

    /**
     * Operation unlockCustomerWithHttpInfo
     *
     * Unlock the customer
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockCustomer'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unlockCustomerWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['unlockCustomer'][0]
    ): array
    {
        $request = $this->unlockCustomerRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation unlockCustomerAsync
     *
     * Unlock the customer
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockCustomer'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unlockCustomerAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['unlockCustomer'][0]
    ): PromiseInterface
    {
        return $this->unlockCustomerAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unlockCustomerAsyncWithHttpInfo
     *
     * Unlock the customer
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockCustomer'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unlockCustomerAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['unlockCustomer'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->unlockCustomerRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unlockCustomer'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockCustomer'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unlockCustomerRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['unlockCustomer'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling unlockCustomer'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/customer/unlock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unlockSupplier
     *
     * Unlock the supplier
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockSupplier'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function unlockSupplier(
        string $contactAccountRef,
        string $contentType = self::contentTypes['unlockSupplier'][0]
    ): void
    {
        $this->unlockSupplierWithHttpInfo($contactAccountRef, $contentType);
    }

    /**
     * Operation unlockSupplierWithHttpInfo
     *
     * Unlock the supplier
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockSupplier'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unlockSupplierWithHttpInfo(
        string $contactAccountRef,
        string $contentType = self::contentTypes['unlockSupplier'][0]
    ): array
    {
        $request = $this->unlockSupplierRequest($contactAccountRef, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation unlockSupplierAsync
     *
     * Unlock the supplier
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockSupplier'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unlockSupplierAsync(
        string $contactAccountRef,
        string $contentType = self::contentTypes['unlockSupplier'][0]
    ): PromiseInterface
    {
        return $this->unlockSupplierAsyncWithHttpInfo($contactAccountRef, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unlockSupplierAsyncWithHttpInfo
     *
     * Unlock the supplier
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockSupplier'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function unlockSupplierAsyncWithHttpInfo(
        $contactAccountRef,
        string $contentType = self::contentTypes['unlockSupplier'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->unlockSupplierRequest($contactAccountRef, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unlockSupplier'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unlockSupplier'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unlockSupplierRequest(
        $contactAccountRef,
        string $contentType = self::contentTypes['unlockSupplier'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling unlockSupplier'
            );
        }


        $resourcePath = '/api/ContactAccount/{contactAccountRef}/supplier/unlock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateContactAccount
     *
     * Update a contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactAccountUpdate|null $contactAccountUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return string
     */
    public function updateContactAccount(
        string $contactAccountRef,
        ?\SynergiTech\Iplicit\Model\ContactAccountUpdate $contactAccountUpdate = null,
        string $contentType = self::contentTypes['updateContactAccount'][0]
    ): string
    {
        list($response) = $this->updateContactAccountWithHttpInfo($contactAccountRef, $contactAccountUpdate, $contentType);
        return $response;
    }

    /**
     * Operation updateContactAccountWithHttpInfo
     *
     * Update a contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactAccountUpdate|null $contactAccountUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccount'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContactAccountWithHttpInfo(
        string $contactAccountRef,
        ?\SynergiTech\Iplicit\Model\ContactAccountUpdate $contactAccountUpdate = null,
        string $contentType = self::contentTypes['updateContactAccount'][0]
    ): array
    {
        $request = $this->updateContactAccountRequest($contactAccountRef, $contactAccountUpdate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if (in_array('string', ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateContactAccountAsync
     *
     * Update a contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactAccountUpdate|null $contactAccountUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateContactAccountAsync(
        string $contactAccountRef,
        ?\SynergiTech\Iplicit\Model\ContactAccountUpdate $contactAccountUpdate = null,
        string $contentType = self::contentTypes['updateContactAccount'][0]
    ): PromiseInterface
    {
        return $this->updateContactAccountAsyncWithHttpInfo($contactAccountRef, $contactAccountUpdate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateContactAccountAsyncWithHttpInfo
     *
     * Update a contact account
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactAccountUpdate|null $contactAccountUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateContactAccountAsyncWithHttpInfo(
        $contactAccountRef,
        $contactAccountUpdate = null,
        string $contentType = self::contentTypes['updateContactAccount'][0]
    ): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->updateContactAccountRequest($contactAccountRef, $contactAccountUpdate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if (in_array($returnType, ['\SplFileObject', '\Psr\Http\Message\StreamInterface'])) {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateContactAccount'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactAccountUpdate|null $contactAccountUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccount'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateContactAccountRequest(
        $contactAccountRef,
        $contactAccountUpdate = null,
        string $contentType = self::contentTypes['updateContactAccount'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling updateContactAccount'
            );
        }



        $resourcePath = '/api/ContactAccount/{contactAccountRef}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($contactAccountUpdate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($contactAccountUpdate));
            } else {
                $httpBody = $contactAccountUpdate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateContactAccountBankDetails
     *
     * Replace bank details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactBankDetailsUpdateable|null $contactBankDetailsUpdateable  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountBankDetails'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function updateContactAccountBankDetails(
        string $contactAccountRef,
        ?\SynergiTech\Iplicit\Model\ContactBankDetailsUpdateable $contactBankDetailsUpdateable = null,
        string $contentType = self::contentTypes['updateContactAccountBankDetails'][0]
    ): void
    {
        $this->updateContactAccountBankDetailsWithHttpInfo($contactAccountRef, $contactBankDetailsUpdateable, $contentType);
    }

    /**
     * Operation updateContactAccountBankDetailsWithHttpInfo
     *
     * Replace bank details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactBankDetailsUpdateable|null $contactBankDetailsUpdateable  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountBankDetails'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContactAccountBankDetailsWithHttpInfo(
        string $contactAccountRef,
        ?\SynergiTech\Iplicit\Model\ContactBankDetailsUpdateable $contactBankDetailsUpdateable = null,
        string $contentType = self::contentTypes['updateContactAccountBankDetails'][0]
    ): array
    {
        $request = $this->updateContactAccountBankDetailsRequest($contactAccountRef, $contactBankDetailsUpdateable, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateContactAccountBankDetailsAsync
     *
     * Replace bank details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactBankDetailsUpdateable|null $contactBankDetailsUpdateable  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountBankDetails'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateContactAccountBankDetailsAsync(
        string $contactAccountRef,
        ?\SynergiTech\Iplicit\Model\ContactBankDetailsUpdateable $contactBankDetailsUpdateable = null,
        string $contentType = self::contentTypes['updateContactAccountBankDetails'][0]
    ): PromiseInterface
    {
        return $this->updateContactAccountBankDetailsAsyncWithHttpInfo($contactAccountRef, $contactBankDetailsUpdateable, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateContactAccountBankDetailsAsyncWithHttpInfo
     *
     * Replace bank details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactBankDetailsUpdateable|null $contactBankDetailsUpdateable  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountBankDetails'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateContactAccountBankDetailsAsyncWithHttpInfo(
        $contactAccountRef,
        $contactBankDetailsUpdateable = null,
        string $contentType = self::contentTypes['updateContactAccountBankDetails'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->updateContactAccountBankDetailsRequest($contactAccountRef, $contactBankDetailsUpdateable, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateContactAccountBankDetails'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactBankDetailsUpdateable|null $contactBankDetailsUpdateable  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountBankDetails'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateContactAccountBankDetailsRequest(
        $contactAccountRef,
        $contactBankDetailsUpdateable = null,
        string $contentType = self::contentTypes['updateContactAccountBankDetails'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling updateContactAccountBankDetails'
            );
        }



        $resourcePath = '/api/ContactAccount/{contactAccountRef}/bankDetails/default';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($contactBankDetailsUpdateable)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($contactBankDetailsUpdateable));
            } else {
                $httpBody = $contactBankDetailsUpdateable;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateContactAccountContact
     *
     * Update an existing related contact
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountContact'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function updateContactAccountContact(
        string $contactAccountRef,
        string $contactRef,
        ?\SynergiTech\Iplicit\Model\ContactUpdate $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountContact'][0]
    ): void
    {
        $this->updateContactAccountContactWithHttpInfo($contactAccountRef, $contactRef, $contactUpdate, $contentType);
    }

    /**
     * Operation updateContactAccountContactWithHttpInfo
     *
     * Update an existing related contact
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountContact'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContactAccountContactWithHttpInfo(
        string $contactAccountRef,
        string $contactRef,
        ?\SynergiTech\Iplicit\Model\ContactUpdate $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountContact'][0]
    ): array
    {
        $request = $this->updateContactAccountContactRequest($contactAccountRef, $contactRef, $contactUpdate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateContactAccountContactAsync
     *
     * Update an existing related contact
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateContactAccountContactAsync(
        string $contactAccountRef,
        string $contactRef,
        ?\SynergiTech\Iplicit\Model\ContactUpdate $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountContact'][0]
    ): PromiseInterface
    {
        return $this->updateContactAccountContactAsyncWithHttpInfo($contactAccountRef, $contactRef, $contactUpdate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateContactAccountContactAsyncWithHttpInfo
     *
     * Update an existing related contact
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateContactAccountContactAsyncWithHttpInfo(
        $contactAccountRef,
        $contactRef,
        $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountContact'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->updateContactAccountContactRequest($contactAccountRef, $contactRef, $contactUpdate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateContactAccountContact'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  string $contactRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateContactAccountContactRequest(
        $contactAccountRef,
        $contactRef,
        $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountContact'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling updateContactAccountContact'
            );
        }

        // verify the required parameter 'contactRef' is set
        if ($contactRef === null || (is_array($contactRef) && count($contactRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactRef when calling updateContactAccountContact'
            );
        }



        $resourcePath = '/api/ContactAccount/{contactAccountRef}/contacts/{contactRef}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }
        // path params
        if ($contactRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactRef' . '}',
                ObjectSerializer::toPathValue($contactRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($contactUpdate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($contactUpdate));
            } else {
                $httpBody = $contactUpdate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateContactAccountMainContact
     *
     * Update the main contact details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountMainContact'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function updateContactAccountMainContact(
        string $contactAccountRef,
        ?\SynergiTech\Iplicit\Model\ContactUpdate $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountMainContact'][0]
    ): void
    {
        $this->updateContactAccountMainContactWithHttpInfo($contactAccountRef, $contactUpdate, $contentType);
    }

    /**
     * Operation updateContactAccountMainContactWithHttpInfo
     *
     * Update the main contact details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountMainContact'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContactAccountMainContactWithHttpInfo(
        string $contactAccountRef,
        ?\SynergiTech\Iplicit\Model\ContactUpdate $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountMainContact'][0]
    ): array
    {
        $request = $this->updateContactAccountMainContactRequest($contactAccountRef, $contactUpdate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateContactAccountMainContactAsync
     *
     * Update the main contact details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountMainContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateContactAccountMainContactAsync(
        string $contactAccountRef,
        ?\SynergiTech\Iplicit\Model\ContactUpdate $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountMainContact'][0]
    ): PromiseInterface
    {
        return $this->updateContactAccountMainContactAsyncWithHttpInfo($contactAccountRef, $contactUpdate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateContactAccountMainContactAsyncWithHttpInfo
     *
     * Update the main contact details
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountMainContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateContactAccountMainContactAsyncWithHttpInfo(
        $contactAccountRef,
        $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountMainContact'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->updateContactAccountMainContactRequest($contactAccountRef, $contactUpdate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateContactAccountMainContact'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountMainContact'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateContactAccountMainContactRequest(
        $contactAccountRef,
        $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountMainContact'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling updateContactAccountMainContact'
            );
        }



        $resourcePath = '/api/ContactAccount/{contactAccountRef}/contact';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($contactUpdate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($contactUpdate));
            } else {
                $httpBody = $contactUpdate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateContactAccountRelatedContacts
     *
     * Update existing contacts.                Existing contacts are matched to request contacts by ID, IntRef or Description and updated.              Existing contacts that do not match any request contact are left unchanged.              Request contacts that do not match any existing contact are added.
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate[]|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountRelatedContacts'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return void
     */
    public function updateContactAccountRelatedContacts(
        string $contactAccountRef,
        ?array $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountRelatedContacts'][0]
    ): void
    {
        $this->updateContactAccountRelatedContactsWithHttpInfo($contactAccountRef, $contactUpdate, $contentType);
    }

    /**
     * Operation updateContactAccountRelatedContactsWithHttpInfo
     *
     * Update existing contacts.                Existing contacts are matched to request contacts by ID, IntRef or Description and updated.              Existing contacts that do not match any request contact are left unchanged.              Request contacts that do not match any existing contact are added.
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate[]|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountRelatedContacts'] to see the possible values for this operation
     *
     * @throws ApiException on non-2xx response or if the response body is not in the expected format
     * @throws InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateContactAccountRelatedContactsWithHttpInfo(
        string $contactAccountRef,
        ?array $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountRelatedContacts'][0]
    ): array
    {
        $request = $this->updateContactAccountRelatedContactsRequest($contactAccountRef, $contactUpdate, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateContactAccountRelatedContactsAsync
     *
     * Update existing contacts.                Existing contacts are matched to request contacts by ID, IntRef or Description and updated.              Existing contacts that do not match any request contact are left unchanged.              Request contacts that do not match any existing contact are added.
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate[]|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountRelatedContacts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateContactAccountRelatedContactsAsync(
        string $contactAccountRef,
        ?array $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountRelatedContacts'][0]
    ): PromiseInterface
    {
        return $this->updateContactAccountRelatedContactsAsyncWithHttpInfo($contactAccountRef, $contactUpdate, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateContactAccountRelatedContactsAsyncWithHttpInfo
     *
     * Update existing contacts.                Existing contacts are matched to request contacts by ID, IntRef or Description and updated.              Existing contacts that do not match any request contact are left unchanged.              Request contacts that do not match any existing contact are added.
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate[]|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountRelatedContacts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return PromiseInterface
     */
    public function updateContactAccountRelatedContactsAsyncWithHttpInfo(
        $contactAccountRef,
        $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountRelatedContacts'][0]
    ): PromiseInterface
    {
        $returnType = '';
        $request = $this->updateContactAccountRelatedContactsRequest($contactAccountRef, $contactUpdate, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateContactAccountRelatedContacts'
     *
     * @param  string $contactAccountRef Id, code or &lt;a href&#x3D;\&quot;https://docs.iplicit.com/dev/guide/identifiers/index.html\&quot;&gt;internal reference&lt;/a&gt; of the contact account (required)
     * @param  \SynergiTech\Iplicit\Model\ContactUpdate[]|null $contactUpdate  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateContactAccountRelatedContacts'] to see the possible values for this operation
     *
     * @throws InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateContactAccountRelatedContactsRequest(
        $contactAccountRef,
        $contactUpdate = null,
        string $contentType = self::contentTypes['updateContactAccountRelatedContacts'][0]
    ): Request
    {

        // verify the required parameter 'contactAccountRef' is set
        if ($contactAccountRef === null || (is_array($contactAccountRef) && count($contactAccountRef) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $contactAccountRef when calling updateContactAccountRelatedContacts'
            );
        }



        $resourcePath = '/api/ContactAccount/{contactAccountRef}/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($contactAccountRef !== null) {
            $resourcePath = str_replace(
                '{' . 'contactAccountRef' . '}',
                ObjectSerializer::toPathValue($contactAccountRef),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($contactUpdate)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($contactUpdate));
            } else {
                $httpBody = $contactUpdate;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        if (!empty($this->config->getDomainHeader())) {
            $headers['Domain'] = $this->config->getDomainHeader();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption(): array
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
